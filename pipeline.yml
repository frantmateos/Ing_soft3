trigger:
  branches:
    include:
      - tomi

pool:
  name: MiPool

variables:
  # ====== Apps / Infra ======
  - name: azureSubscription
    value: 'tp05-connection'
  - name: webAppFrontendQA
    value: 'webapp-QA-2025'
  - name: webAppBackendQA
    value: 'BACKEND-QA-2025'
  - name: REACT_APP_BACKEND_URL_QA
    value: 'https://backend-qa-2025.azurewebsites.net'
  - name: webAppFrontendPROD
    value: 'webapp-PRODU-2025'
  - name: webAppBackendPROD
    value: 'BACKEND-PRODU-2025'
  - name: REACT_APP_BACKEND_URL_PROD
    value: 'https://backend-produ-2025.azurewebsites.net'
  - name: acrLoginServer
    value: 'ingsoft3ucc.azurecr.io'
  - name: acrConnection
    value: 'DockerServicee'
  - name: backendImage
    value: 'backend'
  - name: frontendImage
    value: 'frontend'

  # ====== SonarCloud (tomado del pipeline de tu amigo y adaptado) ======
  - name: sonarServiceConnection
    value: 'SonarCloud'           # tu Service Connection
  - name: sonarOrg
    value: 'frantmateos'          # tu organizaciÃ³n
  - name: sonarFrontProjectKey
    value: 'Ing_soft3_frontend'   # proyecto FRONT en SonarCloud
  - name: sonarFrontProjectName
    value: 'frontend'
  - name: sonarBackProjectKey
    value: 'Ing_soft3_backend'    # proyecto BACK en SonarCloud
  - name: sonarBackProjectName
    value: 'backend'

stages:
# ======================================================
# =                BUILD & TEST (CI)                  =
# ======================================================
- stage: BuildAndTest
  displayName: "Build, Test Frontend & Backend"
  jobs:

  # ---------- FRONTEND QA ----------
  - job: BuildAndTestFrontQA
    displayName: "Build & Test Frontend (QA)"
    steps:
      - task: NodeTool@0
        inputs:
          versionSpec: '16.x'
        displayName: "Set Node.js 16.x"

      - task: CmdLine@2
        displayName: "Install, Test & Build Frontend for QA"
        inputs:
          script: |
            set -e
            cd frontend

            echo "Node/npm:"
            node -v
            npm -v

            echo "REACT_APP_BACKEND_URL=${REACT_APP_BACKEND_URL_QA}" > .env
            echo "Usando .env:" && cat .env

            npm config set engine-strict false
            npm config set legacy-peer-deps true
            npm config set audit false
            npm config set fund false

            # deps
            if ! npm ci --no-audit --no-fund --legacy-peer-deps --unsafe-perm; then
              rm -rf node_modules package-lock.json
              npm install --no-audit --no-fund --legacy-peer-deps --unsafe-perm
            fi

            # tests (Jest)
            npm test -- --watchAll=false

            # build (sin cortar por warnings)
            CI=false DISABLE_ESLINT_PLUGIN=true npm run build

            # server Node para Azure
            cat > build/server.js <<'EOF'
            const express = require("express");
            const path = require("path");
            const compression = require("compression");
            const app = express();
            const port = process.env.PORT || 8080;
            app.use(compression());
            app.use(express.static(path.join(__dirname)));
            app.get("*", (_, res) => res.sendFile(path.join(__dirname, "index.html")));
            app.listen(port, () => console.log(`âœ… Frontend running on port ${port}`));
            EOF

            cat > build/package.json <<'EOF'
            {
              "name": "frontend-spa",
              "version": "1.0.0",
              "scripts": { "start": "node server.js" },
              "dependencies": { "express": "^4.18.2", "compression": "^1.7.4" }
            }
            EOF

            cd build && npm install --production --no-audit --no-fund

      # ==== PUBLICAR COVERAGE (como en el pipeline de tu amigo) ====
      - task: CmdLine@2
        displayName: "Run Jest with Coverage (lcov + cobertura)"
        inputs:
          script: |
            set -e
            cd frontend
            npm test -- --coverage --watchAll=false --coverageReporters=lcov --coverageReporters=cobertura

      - task: PublishCodeCoverageResults@2
        displayName: "Publish Frontend Coverage (Cobertura)"
        inputs:
          codeCoverageTool: 'Cobertura'
          summaryFileLocation: 'frontend/coverage/cobertura-coverage.xml'
          reportDirectory: 'frontend/coverage'
          failIfCoverageEmpty: false

      # ==== SONARCLOUD FRONTEND (traÃ­do del ejemplo y adaptado) ====
      - task: SonarCloudPrepare@3
        displayName: "SonarCloud Prepare (Frontend)"
        inputs:
          SonarQube: '$(sonarServiceConnection)'
          organization: '$(sonarOrg)'
          scannerMode: 'CLI'
          configMode: 'manual'
          cliProjectKey: '$(sonarFrontProjectKey)'
          cliProjectName: '$(sonarFrontProjectName)'
          extraProperties: |
            sonar.projectBaseDir=$(Build.SourcesDirectory)/frontend
            sonar.sources=src
            sonar.tests=src
            sonar.test.inclusions=**/*.test.*,**/*.spec.*
            sonar.javascript.lcov.reportPaths=coverage/lcov.info
            sonar.exclusions=**/node_modules/**,**/*.test.*,**/__mocks__/**
            sonar.branch.name=$(Build.SourceBranchName)
            sonar.verbose=true

      - task: SonarCloudAnalyze@3
        displayName: "SonarCloud Analyze (Frontend)"
        inputs:
          jdkversion: 'JAVA_HOME_17_X64'   # igual que el de tu amigo

      - task: SonarCloudPublish@3
        displayName: "SonarCloud Publish (Frontend)"
        inputs:
          pollingTimeoutSec: '300'

      - task: ArchiveFiles@2
        displayName: "Zip Frontend QA build"
        inputs:
          rootFolderOrFile: 'frontend/build'
          includeRootFolder: false
          archiveType: 'zip'
          archiveFile: '$(Build.ArtifactStagingDirectory)/frontend-qa.zip'
          replaceExistingArchive: true

      - task: PublishPipelineArtifact@1
        displayName: "Publish Frontend QA Artifact"
        inputs:
          targetPath: '$(Build.ArtifactStagingDirectory)/frontend-qa.zip'
          artifactName: 'drop_front_qa'

  # ---------- FRONTEND PROD ----------
  - job: BuildFrontPROD
    displayName: "Build Frontend (Production)"
    steps:
      - task: NodeTool@0
        inputs:
          versionSpec: '16.x'
        displayName: "Set Node.js 16.x"

      - task: CmdLine@2
        displayName: "Build Frontend for Production"
        inputs:
          script: |
            set -e
            cd frontend
            echo "REACT_APP_BACKEND_URL=${REACT_APP_BACKEND_URL_PROD}" > .env
            cat .env
            npm install
            npm run build

            # server Node para Azure
            cat > build/server.js <<'EOF'
            const express = require("express");
            const path = require("path");
            const compression = require("compression");
            const app = express();
            const port = process.env.PORT || 8080;
            app.use(compression());
            app.use(express.static(path.join(__dirname)));
            app.get("*", (_, res) => res.sendFile(path.join(__dirname, "index.html")));
            app.listen(port, () => console.log(`âœ… Frontend running on port ${port}`));
            EOF

            cat > build/package.json <<'EOF'
            {
              "name": "frontend-spa",
              "version": "1.0.0",
              "scripts": { "start": "node server.js" },
              "dependencies": { "express": "^4.18.2", "compression": "^1.7.4" }
            }
            EOF

            cd build && npm install --production

      - task: ArchiveFiles@2
        displayName: "Zip Frontend PROD build"
        inputs:
          rootFolderOrFile: 'frontend/build'
          includeRootFolder: false
          archiveType: 'zip'
          archiveFile: '$(Build.ArtifactStagingDirectory)/frontend-prod.zip'
          replaceExistingArchive: true

      - task: PublishPipelineArtifact@1
        displayName: "Publish Frontend PROD Artifact"
        inputs:
          targetPath: '$(Build.ArtifactStagingDirectory)/frontend-prod.zip'
          artifactName: 'drop_front_prod'

  # ---------- BACKEND (Go) ----------
  - job: BuildAndTestBack
    displayName: "Build & Test Backend (Go)"
    steps:
      - checkout: self
        fetchDepth: 0

      - task: GoTool@0
        inputs:
          version: '1.22.1'
        displayName: "Use Go 1.22.1"

      - task: CmdLine@2
        displayName: "Tidy, Test (coverage) & Build Backend"
        inputs:
          script: |
            set -e
            cd Golang
            go mod tidy
            go test ./... -coverprofile=coverage.out -covermode=atomic
            echo "Primeras lÃ­neas coverage.out:" && head -n 20 coverage.out || true
            GOOS=linux GOARCH=amd64 go build -o ../app

      # ==== PUBLICAR COVERAGE BACK (como en el pipeline de tu amigo) ====
      - task: PublishCodeCoverageResults@2
        displayName: "Publish Backend Coverage (Go)"
        inputs:
          codeCoverageTool: 'Cobertura'
          summaryFileLocation: 'Golang/coverage.out'
          reportDirectory: 'Golang'
          failIfCoverageEmpty: false

      # ==== SONARCLOUD BACKEND (traÃ­do del ejemplo y adaptado) ====
      - task: SonarCloudPrepare@3
        displayName: "SonarCloud Prepare (Backend)"
        inputs:
          SonarQube: '$(sonarServiceConnection)'
          organization: '$(sonarOrg)'
          scannerMode: 'CLI'
          configMode: 'file'
          cliProjectKey: '$(sonarBackProjectKey)'
          cliProjectName: '$(sonarBackProjectName)'
          extraProperties: |
            sonar.projectBaseDir=$(Build.SourcesDirectory)/Golang
            sonar.sources=.
            sonar.exclusions=**/vendor/**,**/tests/**
            sonar.language=go
            sonar.go.coverage.reportPaths=coverage.out
            sonar.branch.name=$(Build.SourceBranchName)
            sonar.verbose=true

      - task: SonarCloudAnalyze@3
        displayName: "Run SonarCloud Analysis (Backend)"
        inputs:
          jdkversion: 'JAVA_HOME_17_X64'   # igual al de tu amigo

      - task: SonarCloudPublish@3
        displayName: "Publish SonarCloud Results (Backend)"
        inputs:
          pollingTimeoutSec: '300'

      - task: ArchiveFiles@2
        displayName: "Zip backend binary"
        inputs:
          rootFolderOrFile: 'app'
          includeRootFolder: false
          archiveType: 'zip'
          archiveFile: '$(Build.ArtifactStagingDirectory)/backend.zip'
          replaceExistingArchive: true

      - task: PublishPipelineArtifact@1
        displayName: "Publish Backend Artifact"
        inputs:
          targetPath: '$(Build.ArtifactStagingDirectory)/backend.zip'
          artifactName: 'drop_back'

# ======================================================
# =            BUILD & PUSH DOCKER IMAGES              =
# ======================================================
- stage: BuildAndPushImages
  displayName: "ğŸ³ Build & Push Docker Images"
  dependsOn: BuildAndTest
  condition: succeeded()
  jobs:
    - job: DockerBuildPush
      displayName: "Build & Push Backend and Frontend images"
      steps:
        - task: Docker@2
          displayName: "Build & Push Backend Image"
          inputs:
            command: buildAndPush
            containerRegistry: '$(acrConnection)'
            repository: '$(backendImage)'
            dockerfile: 'Golang/Dockerfile'
            buildContext: '.'
            tags: |
              latest
              $(Build.BuildId)

        - task: Docker@2
          displayName: "Build & Push Frontend Image"
          inputs:
            command: buildAndPush
            containerRegistry: '$(acrConnection)'
            repository: '$(frontendImage)'
            dockerfile: 'frontend/Dockerfile'
            buildContext: './frontend'
            tags: |
              latest
              $(Build.BuildId)

# ======================================================
# =                     DEPLOY QA                      =
# ======================================================
- stage: DeployQA
  displayName: "ğŸš€ Deploy to QA (Containers)"
  dependsOn: BuildAndPushImages
  jobs:
    - job: DeployContainersQA
      steps:
        - task: AzureWebAppContainer@1
          displayName: "Deploy Backend QA Container"
          inputs:
            azureSubscription: '$(azureSubscription)'
            appName: 'docker-backend-qa'
            containers: |
              $(acrLoginServer)/$(backendImage):latest

        - task: AzureWebAppContainer@1
          displayName: "Deploy Frontend QA Container"
          inputs:
            azureSubscription: '$(azureSubscription)'
            appName: 'docker-frontend-qa'
            containers: |
              $(acrLoginServer)/$(frontendImage):latest

# ======================================================
# =                   E2E QA (Cypress)                 =
# ======================================================
- stage: E2E_QA
  displayName: "ğŸ§ª E2E Cypress contra QA"
  dependsOn: DeployQA
  condition: succeeded()
  jobs:
    - job: CypressRunQA
      displayName: "Run Cypress E2E (QA)"
      pool: { name: MiPool }
      steps:
        - task: NodeTool@0
          inputs: { versionSpec: '16.x' }
          displayName: "Set Node.js 16.x"

        - script: |
            set -e
            cd frontend
            npm ci --no-audit --no-fund --legacy-peer-deps || npm install --no-audit --no-fund --legacy-peer-deps
            npx cypress verify
          displayName: "Install Cypress"

        - script: |
            set -e
            cd frontend
            rm -rf cypress/results || true
            mkdir -p cypress/results
            npx cypress run \
              --spec "cypress/e2e/test-*.cy.js" \
              --reporter junit \
              --reporter-options "mochaFile=cypress/results/junit-[hash].xml,toConsole=true" \
              --config baseUrl=https://$(webAppFrontendQA).azurewebsites.net,video=true,videoCompression=32
          displayName: "Run Cypress (headless, JUnit)"

        - task: PublishTestResults@2
          displayName: "Publicar resultados Cypress (JUnit)"
          inputs:
            testResultsFormat: 'JUnit'
            testResultsFiles: 'frontend/cypress/results/*.xml'
            mergeTestResults: true
            failTaskOnFailedTests: true

        - task: PublishPipelineArtifact@1
          displayName: "Adjuntar videos/screenshots Cypress"
          inputs:
            targetPath: 'frontend/cypress'
            artifactName: 'cypress_e2e_artifacts'

# ======================================================
# =                      DEPLOY PROD                   =
# ======================================================
- stage: DeployPROD
  displayName: "ğŸš€ Deploy to Production (Manual Approval)"
  dependsOn:
    - DeployQA
    - E2E_QA
  condition: succeeded()
  jobs:
    - deployment: DeployFrontendPROD
      displayName: "Deploy Frontend PROD"
      environment: { name: 'PRODU' }
      strategy:
        runOnce:
          deploy:
            steps:
              - task: DownloadPipelineArtifact@2
                inputs:
                  artifact: 'drop_front_prod'
                  path: '$(Pipeline.Workspace)/drop_front_prod'
                displayName: 'Download Frontend PROD Artifact'
              - task: AzureWebApp@1
                displayName: "Deploy Frontend to PROD Web App"
                inputs:
                  azureSubscription: '$(azureSubscription)'
                  appType: 'webApp'
                  appName: '$(webAppFrontendPROD)'
                  package: '$(Pipeline.Workspace)/drop_front_prod/frontend-prod.zip'

    - deployment: DeployBackendPROD
      displayName: "Deploy Backend PROD"
      environment: { name: 'PRODU' }
      strategy:
        runOnce:
          deploy:
            steps:
              - task: DownloadPipelineArtifact@2
                inputs:
                  artifact: 'drop_back'
                  path: '$(Pipeline.Workspace)/drop_back'
                displayName: 'Download Backend Artifact'
              - task: AzureWebApp@1
                displayName: "Deploy Backend to PROD Web App"
                inputs:
                  azureSubscription: '$(azureSubscription)'
                  appType: 'webApp'
                  appName: '$(webAppBackendPROD)'
                  package: '$(Pipeline.Workspace)/drop_back/backend.zip'
                  appSettings: |
                    -name WEBSITE_STARTUP_FILE -value ./app
