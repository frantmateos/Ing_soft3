trigger:
  branches:
    include:
      - tomi

pool:
  name: MiPool

variables:
  # ====== Apps / Infra ======
  - name: azureSubscription
    value: 'tp05-connection'
  - name: webAppFrontendQA
    value: 'webapp-QA-2025'
  - name: webAppBackendQA
    value: 'BACKEND-QA-2025'
  - name: REACT_APP_BACKEND_URL_QA
    value: 'https://backend-qa-2025.azurewebsites.net'
  - name: webAppFrontendPROD
    value: 'webapp-PRODU-2025'
  - name: webAppBackendPROD
    value: 'BACKEND-PRODU-2025'
  - name: REACT_APP_BACKEND_URL_PROD
    value: 'https://backend-produ-2025.azurewebsites.net'
  - name: acrLoginServer
    value: 'ingsoft3ucc.azurecr.io'
  - name: acrConnection
    value: 'DockerServicee'
  - name: backendImage
    value: 'backend'
  - name: frontendImage
    value: 'frontend'

  # ====== SonarCloud ======
  - name: sonarServiceConnection
    value: 'SonarCloud'
  - name: sonarOrg
    value: 'frantmateos'

stages:

# ======================================================
# =         BUILD & TEST (CI)                        =
# ======================================================
- stage: BuildAndTest
  displayName: "Build, Test Frontend & Backend"
  jobs:

  # ---------- FRONTEND QA ----------
  - job: BuildAndTestFrontQA
    displayName: "Build & Test Frontend (QA)"
    steps:
      - task: NodeTool@0
        inputs:
          versionSpec: '16.x'
        displayName: "Set Node.js 16.x"

      - task: CmdLine@2
        displayName: "Install, Test (con Cobertura) & Build Frontend"
        inputs:
          script: |
            set -e
            cd frontend
            echo "REACT_APP_BACKEND_URL=${REACT_APP_BACKEND_URL_QA}" > .env
            npm config set engine-strict false
            npm config set legacy-peer-deps true
            npm config set audit false
            npm config set fund false
            echo "ğŸ“¦ npm ci"
            if ! npm ci --no-audit --no-fund --legacy-peer-deps --unsafe-perm; then
              rm -rf node_modules package-lock.json
              npm install --no-audit --no-fund --legacy-peer-deps --unsafe-perm
            fi
            
            # --- Generar Cobertura para Sonar ---
            echo "ğŸ§ª Tests (con lcov para Sonar)"
            # Esta lÃ­nea es la que crea el 'frontend/coverage/lcov.info'
            npm test -- --coverage --watchAll=false --coverageReporters=lcov --coverageReporters=cobertura

            echo "ğŸŒ Build QA"
            CI=false DISABLE_ESLINT_PLUGIN=true npm run build
            
            echo "ğŸ§© Server Node para Azure App Service"
            cat > build/server.js <<'EOF'
            const express = require("express");
            const path = require("path");
            const compression = require("compression");
            const app = express();
            const port = process.env.PORT || 8080;
            app.use(compression());
            app.use(express.static(path.join(__dirname)));
            app.get("*", (_, res) => res.sendFile(path.join(__dirname, "index.html")));
            app.listen(port, () => console.log(`âœ… Frontend running on port ${port}`));
            EOF
            cat > build/package.json <<'EOF'
            {
              "name": "frontend-spa",
              "version": "1.0.0",
              "scripts": { "start": "node server.js" },
              "dependencies": {
                "express": "^4.18.2",
                "compression": "^1.7.4"
              }
            }
            EOF
            cd build
            npm install --production --no-audit --no-fund

      - task: PublishCodeCoverageResults@2
        displayName: "Publish Frontend Coverage (Cobertura)"
        inputs:
          codeCoverageTool: 'Cobertura'
          summaryFileLocation: 'frontend/coverage/cobertura-coverage.xml'
          reportDirectory: 'frontend/coverage'
          failIfCoverageEmpty: false

      - task: ArchiveFiles@2
        displayName: "Zip Frontend QA build"
        inputs:
          rootFolderOrFile: 'frontend/build'
          includeRootFolder: false
          archiveType: 'zip'
          archiveFile: '$(Build.ArtifactStagingDirectory)/frontend-qa.zip'
          replaceExistingArchive: true

      - task: PublishPipelineArtifact@1
        displayName: "Publish Frontend QA Artifact (dist)"
        inputs:
          targetPath: '$(Build.ArtifactStagingDirectory)/frontend-qa.zip'
          artifactName: 'drop_front_qa'
      
      # =========================================================
      # â–¼â–¼ TAREA CLAVE #1: PUBLICAR LA COBERTURA DEL FRONTEND â–¼â–¼
      # =========================================================
      - task: PublishPipelineArtifact@1
        displayName: 'Publish Frontend Coverage Artifact (lcov)'
        inputs:
          targetPath: 'frontend/coverage' # Sube la carpeta 'coverage' completa
          artifactName: 'frontend_coverage_lcov'
      # =========================================================

  # ---------- FRONTEND PROD ----------
  - job: BuildFrontPROD
    displayName: "Build Frontend (Production)"
    steps:
      - task: NodeTool@0
        inputs:
          versionSpec: '16.x'
        displayName: "Set Node.js 16.x"
      - task: CmdLine@2
        displayName: "Build Frontend for Production"
        inputs:
          script: |
            set -e
            cd frontend
            echo "REACT_APP_BACKEND_URL=${REACT_APP_BACKEND_URL_PROD}" > .env
            npm install
            npm run build
            echo "Server Node para Azure"
            cat > build/server.js <<'EOF'
            const express = require("express");
            const path = require("path");
            const compression = require("compression");
            const app = express();
            const port = process.env.PORT || 8080;
            app.use(compression());
            app.use(express.static(path.join(__dirname)));
            app.get("*", (_, res) => res.sendFile(path.join(__dirname, "index.html")));
            app.listen(port, () => console.log(`âœ… Frontend running on port ${port}`));
            EOF
            cat > build/package.json <<'EOF'
            {
              "name": "frontend-spa",
              "version": "1.0.0",
              "scripts": { "start": "node server.js" },
              "dependencies": {
                "express": "^4.18.2",
                "compression": "^1.7.4"
              }
            }
            EOF
            cd build
            npm install --production
      - task: ArchiveFiles@2
        displayName: "Zip Frontend PROD build"
        inputs:
          rootFolderOrFile: 'frontend/build'
          includeRootFolder: false
          archiveType: 'zip'
          archiveFile: '$(Build.ArtifactStagingDirectory)/frontend-prod.zip'
          replaceExistingArchive: true
      - task: PublishPipelineArtifact@1
        displayName: "Publish Frontend PROD Artifact"
        inputs:
          targetPath: '$(Build.ArtifactStagingDirectory)/frontend-prod.zip'
          artifactName: 'drop_front_prod'

  # ---------- BACKEND (Go) + SONARQUBE ----------
  - job: BuildAndTestBack
    displayName: "Build & Test Backend (Go) + SonarQube"
    dependsOn: BuildAndTestFrontQA # <-- Se asegura que la cobertura del Front ya exista
    steps:
      - checkout: self
        fetchDepth: 0 # <-- Requerido por Sonar

      # =========================================================
      # â–¼â–¼ TAREA CLAVE #2: DESCARGAR LA COBERTURA DEL FRONTEND â–¼â–¼
      # =========================================================
      - task: DownloadPipelineArtifact@2
        displayName: 'Download Frontend Coverage Artifact (lcov)'
        inputs:
          artifact: 'frontend_coverage_lcov'
          # La descargamos en la ruta exacta donde Sonar la va a buscar
          path: '$(Build.SourcesDirectory)/frontend/coverage' 

      - task: GoTool@0
        inputs:
          version: '1.22.1'
        displayName: "Use Go 1.22.1"

      - task: SonarCloudPrepare@3
        displayName: "SonarCloud Prepare (Backend)"
        inputs:
          SonarQube: '$(sonarServiceConnection)'
          organization: '$(sonarOrg)'
          scannerMode: 'CLI'
          configMode: 'file'              # lee sonar-project.properties
          # >>> Pasamos el baseDir correcto desde aquÃ­ <<<
          extraProperties: |
            sonar.projectBaseDir=$(Build.SourcesDirectory)/Golang
            sonar.scanner.dumpToFile=$(Build.SourcesDirectory)/scanner-props-back.txt

      - task: CmdLine@2
        displayName: "Tidy, Test (coverage) & Build Backend"
        inputs:
          script: |
            set -e
            cd Golang
            echo "go mod tidy"
            go mod tidy
            
            echo "Tests con coverage (se guarda en Golang/coverage.out)"
            # Generamos el reporte de cobertura donde Sonar lo espera
            go test ./... -coverprofile=coverage.out -covermode=atomic
            
            echo "ğŸ”¨ Build linux amd64"
            GOOS=linux GOARCH=amd64 go build -o ../app

      - task: PublishCodeCoverageResults@2
        displayName: "Publish Backend Coverage (Go)"
        inputs:
          codeCoverageTool: 'Cobertura'
          summaryFileLocation: 'Golang/coverage.out'
          reportDirectory: 'Golang'
          failIfCoverageEmpty: false
      
      - script: |
          echo "ğŸ” [DEBUG] Verificando AMBOS reportes de cobertura"
          echo "--- Revisando reporte de FRONTEND ---"
          ls -lah $(Build.SourcesDirectory)/frontend/coverage/lcov.info
          head -n 5 $(Build.SourcesDirectory)/frontend/coverage/lcov.info
          
          echo "--- Revisando reporte de BACKEND ---"
          ls -lah $(Build.SourcesDirectory)/Golang/coverage.out
          head -n 5 $(Build.SourcesDirectory)/Golang/coverage.out
        displayName: "DEBUG: Verificar reportes de Cobertura"

      - task: SonarCloudAnalyze@3
        displayName: "Run SonarCloud Analysis (Backend)"
        inputs:
          jdkversion: 'JAVA_HOME_17_X64'

      - task: SonarCloudPublish@3
        displayName: "Publish SonarCloud Results (Backend)"
        inputs:
          pollingTimeoutSec: '300'

      - task: ArchiveFiles@2
        displayName: "Zip backend binary"
        inputs:
          rootFolderOrFile: 'app'
          includeRootFolder: false
          archiveType: 'zip'
          archiveFile: '$(Build.ArtifactStagingDirectory)/backend.zip'
          replaceExistingArchive: true

      - task: PublishPipelineArtifact@1
        displayName: "Publish Backend Artifact"
        inputs:
          targetPath: '$(Build.ArtifactStagingDirectory)/backend.zip'
          artifactName: 'drop_back'

# ======================================================
# =         BUILD & PUSH DOCKER IMAGES                 =
# ======================================================
- stage: BuildAndPushImages
  displayName: "ğŸ³ Build & Push Docker Images"
  dependsOn: BuildAndTest
  condition: succeeded()
  jobs:
    - job: DockerBuildPush
      displayName: "Build & Push Backend and Frontend images"
      steps:
        - task: Docker@2
          displayName: "Build & Push Backend Image"
          inputs:
            command: buildAndPush
            containerRegistry: '$(acrConnection)'
            repository: '$(backendImage)'
            dockerfile: 'Golang/Dockerfile'
            buildContext: '.'
            tags: |
              latest
              $(Build.BuildId)

        - task: Docker@2
          displayName: "Build & Push Frontend Image"
          inputs:
            command: buildAndPush
            containerRegistry: '$(acrConnection)'
            repository: '$(frontendImage)'
            dockerfile: 'frontend/Dockerfile'
            buildContext: './frontend'
            tags: |
              latest
              $(Build.BuildId)

# ======================================================
# =                 DEPLOY QA                          =
# ======================================================
- stage: DeployQA
  displayName: "ğŸš€ Deploy to QA (Containers)"
  dependsOn: BuildAndPushImages
  jobs:
    - job: DeployContainersQA
      steps:
        - task: AzureWebAppContainer@1
          displayName: "Deploy Backend QA Container"
          inputs:
            azureSubscription: '$(azureSubscription)'
            appName: 'docker-backend-qa'
            containers: |
              $(acrLoginServer)/$(backendImage):latest

        - task: AzureWebAppContainer@1
          displayName: "Deploy Frontend QA Container"
          inputs:
            azureSubscription: '$(azureSubscription)'
            appName: 'docker-frontend-qa'
            containers: |
              $(acrLoginServer)/$(frontendImage):latest

# ======================================================
# =               E2E QA (Cypress)                     =
# ======================================================
- stage: E2E_QA
  displayName: "ğŸ§ª E2E Cypress contra QA"
  dependsOn: DeployQA
  condition: succeeded()
  jobs:
    - job: CypressRunQA
      displayName: "Run Cypress E2E (QA)"
      pool:
        name: MiPool
      steps:
        - task: NodeTool@0
          inputs:
            versionSpec: '16.x'
          displayName: "Set Node.js 16.x"

        - script: |
            set -e
            cd frontend
            echo "ğŸ“¦ Instalando deps para Cypress..."
            npm ci --no-audit --no-fund --legacy-peer-deps || npm install --no-audit --no-fund --legacy-peer-deps
            npx cypress verify
          displayName: "Install Cypress"

        - script: |
            set -e
            cd frontend
            echo "ğŸš€ Ejecutando Cypress headless contra QA..."
            rm -rf cypress/results || true
            mkdir -p cypress/results
            npx cypress run \
              --spec "cypress/e2e/test-*.cy.js" \
              --reporter junit \
              --reporter-options "mochaFile=cypress/results/junit-[hash].xml,toConsole=true" \
              --config baseUrl=https://$(webAppFrontendQA).azurewebsites.net,video=true,videoCompression=32
          displayName: "Run Cypress (headless, JUnit)"

        - task: PublishTestResults@2
          displayName: "Publicar resultados Cypress (JUnit)"
          inputs:
            testResultsFormat: 'JUnit'
            testResultsFiles: 'frontend/cypress/results/*.xml'
            mergeTestResults: true
            failTaskOnFailedTests: true

        - task: PublishPipelineArtifact@1
          displayName: "Adjuntar videos/screenshots Cypress"
          inputs:
            targetPath: 'frontend/cypress'
            artifactName: 'cypress_e2e_artifacts'

# ======================================================
# =                 DEPLOY PROD                        =
# ======================================================
- stage: DeployPROD
  displayName: "ğŸš€ Deploy to Production (Manual Approval)"
  dependsOn:
    - DeployQA
    - E2E_QA
  condition: succeeded()
  jobs:
    - deployment: DeployFrontendPROD
      displayName: "Deploy Frontend PROD"
      environment:
        name: 'PRODU'
      strategy:
        runOnce:
          deploy:
            steps:
              - task: DownloadPipelineArtifact@2
                displayName: 'Download Frontend PROD Artifact'
                inputs:
                  artifact: 'drop_front_prod'
                  path: '$(Pipeline.Workspace)/drop_front_prod'
              - task: AzureWebApp@1
                displayName: "Deploy Frontend to PROD Web App"
                inputs:
                  azureSubscription: '$(azureSubscription)'
                  appType: 'webApp'
                  appName: '$(webAppFrontendPROD)'
                  package: '$(Pipeline.Workspace)/drop_front_prod/frontend-prod.zip'

    - deployment: DeployBackendPROD
      displayName: "Deploy Backend PROD"
      environment:
        name: 'PRODU'
      strategy:
        runOnce:
          deploy:
            steps:
              - task: DownloadPipelineArtifact@2
                displayName: 'Download Backend Artifact'
                inputs:
                  artifact: 'drop_back'
                  path: '$(Pipeline.Workspace)/drop_back'
              - task: AzureWebApp@1
                displayName: "Deploy Backend to PROD Web App"
                inputs:
                  azureSubscription: '$(azureSubscription)'
                  appType: 'webApp'
                  appName: '$(webAppBackendPROD)'
                  package: '$(Pipeline.Workspace)/drop_back/backend.zip'
                  appSettings: |
                    -name WEBSITE_STARTUP_FILE -value ./app