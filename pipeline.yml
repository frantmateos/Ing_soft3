trigger:
  branches:
    include:
      - main

pool:
  name: MiPool  # o vmImage: 'ubuntu-latest' si usas Microsoft-hosted

variables:
  azureSubscription: 'tp05-connection'
  webAppFrontendQA: 'webapp-QA-2025'
  webAppBackendQA: 'BACKEND-QA-2025'
  REACT_APP_BACKEND_URL_QA: 'https://backend-qa-2025.azurewebsites.net'
  webAppFrontendPROD: 'webapp-PRODU-2025'
  webAppBackendPROD: 'BACKEND-PRODU-2025'
  REACT_APP_BACKEND_URL_PROD: 'https://backend-produ-2025.azurewebsites.net'
  NODE_VERSION: '16.x'   # <-- Fija Node 16 LTS para evitar ERR_OSSL_EVP_UNSUPPORTED
  GO_VERSION: '1.22.1'

stages:
# ===========================
# STAGE 1: BUILD & TEST
# ===========================
- stage: BuildAndTest
  displayName: "Build & Test Frontend + Backend"
  jobs:

    # ---------- FRONTEND QA ----------
    - job: FrontendQA
      displayName: "Build & Test Frontend (QA)"
      steps:
        - task: NodeTool@0
          displayName: "Use Node $(NODE_VERSION)"
          inputs:
            versionSpec: '$(NODE_VERSION)'

        - task: Cache@2
          displayName: "Cache npm (frontend)"
          inputs:
            key: 'npm | "$(Agent.OS)" | frontend/package-lock.json'
            path: '$(Build.SourcesDirectory)/frontend/node_modules'
            restoreKeys: |
              npm | "$(Agent.OS)" |
              npm |

        - script: |
            set -e
            cd frontend

            echo "CI=true" > .env
            echo "REACT_APP_BACKEND_URL=$(REACT_APP_BACKEND_URL_QA)" >> .env
            echo "Usando .env:"
            cat .env

            echo "ðŸ“¦ npm ci"
            npm ci

            echo "ðŸ§ª npm test (sin watch)"
            npm test -- --watchAll=false

            echo "ðŸŒ npm run build (QA)"
            npm run build

            echo "ðŸ§© Node server para App Service"
            cat > build/server.js <<'EOF'
            const express = require("express");
            const path = require("path");
            const compression = require("compression");
            const app = express();
            const port = process.env.PORT || 8080;
            app.use(compression());
            app.use(express.static(path.join(__dirname)));
            app.get("*", (_, res) => res.sendFile(path.join(__dirname, "index.html")));
            app.listen(port, () => console.log(`âœ… Frontend running on port ${port}`));
            EOF

            cat > build/package.json <<'EOF'
            {
              "name": "frontend-spa",
              "version": "1.0.0",
              "scripts": { "start": "node server.js" },
              "dependencies": {
                "express": "^4.18.2",
                "compression": "^1.7.4"
              }
            }
            EOF

            cd build
            npm install --production
          displayName: "Install, Test & Build Frontend (QA)"
          # Si decides usar Node 18, descomenta env:
          # env:
          #   NODE_OPTIONS: --openssl-legacy-provider

        - task: ArchiveFiles@2
          displayName: "Zip Frontend QA"
          inputs:
            rootFolderOrFile: 'frontend/build'
            includeRootFolder: false
            archiveType: 'zip'
            archiveFile: '$(Build.ArtifactStagingDirectory)/frontend-qa.zip'
            replaceExistingArchive: true

        - publish: $(Build.ArtifactStagingDirectory)/frontend-qa.zip
          artifact: drop_front_qa
          displayName: "Publish Frontend QA Artifact"

    # ---------- FRONTEND PROD ----------
    - job: FrontendPROD
      displayName: "Build Frontend (PROD)"
      steps:
        - task: NodeTool@0
          displayName: "Use Node $(NODE_VERSION)"
          inputs:
            versionSpec: '$(NODE_VERSION)'

        - task: Cache@2
          displayName: "Cache npm (frontend)"
          inputs:
            key: 'npm | "$(Agent.OS)" | frontend/package-lock.json'
            path: '$(Build.SourcesDirectory)/frontend/node_modules'
            restoreKeys: |
              npm | "$(Agent.OS)" |
              npm |

        - script: |
            set -e
            cd frontend

            echo "CI=true" > .env
            echo "REACT_APP_BACKEND_URL=$(REACT_APP_BACKEND_URL_PROD)" >> .env
            echo "Usando .env:"
            cat .env

            echo "ðŸ“¦ npm ci"
            npm ci

            echo "ðŸŒ npm run build (PROD)"
            npm run build

            echo "ðŸ§© Node server para App Service"
            cat > build/server.js <<'EOF'
            const express = require("express");
            const path = require("path");
            const compression = require("compression");
            const app = express();
            const port = process.env.PORT || 8080;
            app.use(compression());
            app.use(express.static(path.join(__dirname)));
            app.get("*", (_, res) => res.sendFile(path.join(__dirname, "index.html")));
            app.listen(port, () => console.log(`âœ… Frontend running on port ${port}`));
            EOF

            cat > build/package.json <<'EOF'
            {
              "name": "frontend-spa",
              "version": "1.0.0",
              "scripts": { "start": "node server.js" },
              "dependencies": {
                "express": "^4.18.2",
                "compression": "^1.7.4"
              }
            }
            EOF

            cd build
            npm install --production
          displayName: "Build Frontend (PROD)"
          # Si decides usar Node 18, descomenta env:
          # env:
          #   NODE_OPTIONS: --openssl-legacy-provider

        - task: ArchiveFiles@2
          displayName: "Zip Frontend PROD"
          inputs:
            rootFolderOrFile: 'frontend/build'
            includeRootFolder: false
            archiveType: 'zip'
            archiveFile: '$(Build.ArtifactStagingDirectory)/frontend-prod.zip'
            replaceExistingArchive: true

        - publish: $(Build.ArtifactStagingDirectory)/frontend-prod.zip
          artifact: drop_front_prod
          displayName: "Publish Frontend PROD Artifact"

    # ---------- BACKEND (Go) ----------
    - job: Backend
      displayName: "Build & Test Backend (Go)"
      steps:
        - task: GoTool@0
          inputs:
            version: '$(GO_VERSION)'
          displayName: "Use Go $(GO_VERSION)"

        - script: |
            set -e
            cd Golang
            echo "ðŸ“¦ go mod tidy"
            go mod tidy
            echo "ðŸ§ª go test ./... -v"
            go test ./... -v
            echo "ðŸ”¨ go build (linux/amd64)"
            GOOS=linux GOARCH=amd64 go build -o ../app
          displayName: "Tidy, Test & Build Backend"

        - task: ArchiveFiles@2
          displayName: "Zip backend binary"
          inputs:
            rootFolderOrFile: 'app'
            includeRootFolder: false
            archiveType: 'zip'
            archiveFile: '$(Build.ArtifactStagingDirectory)/backend.zip'
            replaceExistingArchive: true

        - publish: $(Build.ArtifactStagingDirectory)/backend.zip
          artifact: drop_back
          displayName: "Publish Backend Artifact"

# ===========================
# STAGE 2: DEPLOY QA
# ===========================
- stage: DeployQA
  displayName: "ðŸš€ Deploy to QA"
  dependsOn: BuildAndTest
  condition: succeeded()
  jobs:
    - deployment: DeployFrontendQA
      displayName: "Deploy Frontend QA"
      environment: 'QA'
      strategy:
        runOnce:
          deploy:
            steps:
              - download: current
                artifact: drop_front_qa
              - task: AzureWebApp@1
                displayName: "Deploy Frontend to QA Web App"
                inputs:
                  azureSubscription: '$(azureSubscription)'
                  appType: 'webApp'
                  appName: '$(webAppFrontendQA)'
                  package: '$(Pipeline.Workspace)/drop_front_qa/frontend-qa.zip'

    - deployment: DeployBackendQA
      displayName: "Deploy Backend QA"
      environment: 'QA'
      strategy:
        runOnce:
          deploy:
            steps:
              - download: current
                artifact: drop_back
              - task: AzureWebApp@1
                displayName: "Deploy Backend to QA Web App"
                inputs:
                  azureSubscription: '$(azureSubscription)'
                  appType: 'webApp'
                  appName: '$(webAppBackendQA)'
                  package: '$(Pipeline.Workspace)/drop_back/backend.zip'
                  appSettings: |
                    -name WEBSITE_STARTUP_FILE -value ./app

# ===========================
# STAGE 3: DEPLOY PROD
# ===========================
- stage: DeployPROD
  displayName: "ðŸš€ Deploy to Production (Manual Approval)"
  dependsOn: DeployQA
  condition: succeeded()
  jobs:
    - deployment: DeployFrontendPROD
      displayName: "Deploy Frontend PROD"
      environment: 'PRODU'
      strategy:
        runOnce:
          deploy:
            steps:
              - download: current
                artifact: drop_front_prod
              - task: AzureWebApp@1
                displayName: "Deploy Frontend to PROD Web App"
                inputs:
                  azureSubscription: '$(azureSubscription)'
                  appType: 'webApp'
                  appName: '$(webAppFrontendPROD)'
                  package: '$(Pipeline.Workspace)/drop_front_prod/frontend-prod.zip'

    - deployment: DeployBackendPROD
      displayName: "Deploy Backend PROD"
      environment: 'PRODU'
      strategy:
        runOnce:
          deploy:
            steps:
              - download: current
                artifact: drop_back
              - task: AzureWebApp@1
                displayName: "Deploy Backend to PROD Web App"
                inputs:
                  azureSubscription: '$(azureSubscription)'
                  appType: 'webApp'
                  appName: '$(webAppBackendPROD)'
                  package: '$(Pipeline.Workspace)/drop_back/backend.zip'
                  appSettings: |
                    -name WEBSITE_STARTUP_FILE -value ./app
