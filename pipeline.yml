trigger:
  branches:
    include:
      - tomi

pool:
  name: MiPool

variables:
  # ====== Apps / Infra ======
  - name: azureSubscription
    value: 'tp05-connection'
  - name: webAppFrontendQA
    value: 'webapp-QA-2025'
  - name: webAppBackendQA
    value: 'BACKEND-QA-2025'
  - name: REACT_APP_BACKEND_URL_QA
    value: 'https://backend-qa-2025.azurewebsites.net'
  - name: webAppFrontendPROD
    value: 'webapp-PRODU-2025'
  - name: webAppBackendPROD
    value: 'BACKEND-PRODU-2025'
  - name: REACT_APP_BACKEND_URL_PROD
    value: 'https://backend-produ-2025.azurewebsites.net'
  - name: acrLoginServer
    value: 'ingsoft3ucc.azurecr.io'
  - name: acrConnection
    value: 'DockerServicee'
  - name: backendImage
    value: 'backend'
  - name: frontendImage
    value: 'frontend'
  # ====== SonarCloud ======
  - name: sonarServiceConnection
    value: 'SonarCloud'
  - name: sonarOrg
    value: 'frantmateos'

stages:

# ======================================================
# =         BUILD & TEST (CI)                        =
# ======================================================
- stage: BuildAndTest
  displayName: "Build, Test Frontend & Backend"
  jobs:

  # ---------- FRONTEND QA ----------
  - job: BuildAndTestFrontQA
    displayName: "Build & Test Frontend (QA)"
    steps:
      - task: NodeTool@0
        inputs:
          versionSpec: '16.x'
        displayName: "Set Node.js 16.x"

      - task: CmdLine@2
        displayName: "Install, Test (con Cobertura) & Build Frontend"
        inputs:
          script: |
            set -e
            cd frontend
            echo "REACT_APP_BACKEND_URL=${REACT_APP_BACKEND_URL_QA}" > .env
            npm config set engine-strict false
            npm config set legacy-peer-deps true
            npm config set audit false
            npm config set fund false
            echo "üì¶ npm ci"
            if ! npm ci --no-audit --no-fund --legacy-peer-deps --unsafe-perm; then
              rm -rf node_modules package-lock.json
              npm install --no-audit --no-fund --legacy-peer-deps --unsafe-perm
            fi
            
            # --- Generar Cobertura para Sonar ---
            echo "üß™ Tests (con lcov para Sonar)"
            # Esta l√≠nea es la que crea el 'frontend/coverage/lcov.info'
            npm test -- --coverage --watchAll=false --coverageReporters=lcov --coverageReporters=cobertura

            echo "üåç Build QA"
            CI=false DISABLE_ESLINT_PLUGIN=true npm run build
            
            echo "üß© Server Node para Azure App Service"
            cat > build/server.js <<'EOF'
            const express = require("express");
            const path = require("path");
            const compression = require("compression");
            const app = express();
            const port = process.env.PORT || 8080;
            app.use(compression());
            app.use(express.static(path.join(__dirname)));
            app.get("*", (_, res) => res.sendFile(path.join(__dirname, "index.html")));
            app.listen(port, () => console.log(`‚úÖ Frontend running on port ${port}`));
            EOF
            cat > build/package.json <<'EOF'
            {
              "name": "frontend-spa",
              "version": "1.0.0",
              "scripts": { "start": "node server.js" },
              "dependencies": {
                "express": "^4.18.2",
                "compression": "^1.7.4"
              }
            }
            EOF
            cd build
            npm install --production --no-audit --no-fund

      - task: PublishCodeCoverageResults@2
        displayName: "Publish Frontend Coverage (Cobertura)"
        inputs:
          codeCoverageTool: 'Cobertura'
          summaryFileLocation: 'frontend/coverage/cobertura-coverage.xml'
          reportDirectory: 'frontend/coverage/lcov-report'
          failIfCoverageEmpty: false

      - task: ArchiveFiles@2
        displayName: "Zip Frontend QA build"
        inputs:
          rootFolderOrFile: 'frontend/build'
          includeRootFolder: false
          archiveType: 'zip'
          archiveFile: '$(Build.ArtifactStagingDirectory)/frontend-qa.zip'
          replaceExistingArchive: true

      - task: PublishPipelineArtifact@1
        displayName: "Publish Frontend QA Artifact (dist)"
        inputs:
          targetPath: '$(Build.ArtifactStagingDirectory)/frontend-qa.zip'
          artifactName: 'drop_front_qa'
      
      # =========================================================
      # ‚ñº‚ñº TAREA CLAVE #1: PUBLICAR LA COBERTURA DEL FRONTEND ‚ñº‚ñº
      # =========================================================
      - task: PublishPipelineArtifact@1
        displayName: 'Publish Frontend Coverage Artifact (lcov)'
        inputs:
          targetPath: 'frontend/coverage' # Sube la carpeta 'coverage' completa
          artifactName: 'frontend_coverage_lcov'
      # =========================================================

  # ---------- FRONTEND PROD ----------
  - job: BuildFrontPROD
    displayName: "Build Frontend (Production)"
    steps:
      - task: NodeTool@0
        inputs:
          versionSpec: '16.x'
        displayName: "Set Node.js 16.x"
      - task: CmdLine@2
        displayName: "Build Frontend for Production"
        inputs:
          script: |
            set -e
            cd frontend
            echo "REACT_APP_BACKEND_URL=${REACT_APP_BACKEND_URL_PROD}" > .env
            npm install
            npm run build
            echo "Server Node para Azure"
            cat > build/server.js <<'EOF'
            const express = require("express");
            const path = require("path");
            const compression = require("compression");
            const app = express();
            const port = process.env.PORT || 8080;
            app.use(compression());
            app.use(express.static(path.join(__dirname)));
            app.get("*", (_, res) => res.sendFile(path.join(__dirname, "index.html")));
            app.listen(port, () => console.log(`‚úÖ Frontend running on port ${port}`));
            EOF
            cat > build/package.json <<'EOF'
            {
              "name": "frontend-spa",
              "version": "1.0.0",
              "scripts": { "start": "node server.js" },
              "dependencies": {
                "express": "^4.18.2",
                "compression": "^1.7.4"
              }
            }
            EOF
            cd build
            npm install --production
      - task: ArchiveFiles@2
        displayName: "Zip Frontend PROD build"
        inputs:
          rootFolderOrFile: 'frontend/build'
          includeRootFolder: false
          archiveType: 'zip'
          archiveFile: '$(Build.ArtifactStagingDirectory)/frontend-prod.zip'
          replaceExistingArchive: true
      - task: PublishPipelineArtifact@1
        displayName: "Publish Frontend PROD Artifact"
        inputs:
          targetPath: '$(Build.ArtifactStagingDirectory)/frontend-prod.zip'
          artifactName: 'drop_front_prod'

  # ---------- BACKEND (Go) + SONARQUBE ----------
  - job: BuildAndTestBack
    displayName: "Build & Test Backend (Go) + SonarCloud"
    dependsOn: BuildAndTestFrontQA
    steps:
      - checkout: self
        fetchDepth: 0 # <-- Esta l√≠nea ahora S√ç ser√° le√≠da

      - task: GoTool@0
        inputs:
          version: '1.22.1'
        displayName: "Use Go 1.22.1"

      # PREPARE SonarCloud 100% manual (sin sonar-project.properties)
      - task: SonarCloudPrepare@2
        displayName: "SonarCloud Prepare (Backend)"
        inputs:
          SonarCloud: '$(sonarServiceConnection)' # <-- Este s√≠ es correcto
          organization: '$(sonarOrg)'
          scannerMode: 'CLI'
          configMode: 'manual'
          cliProjectKey: 'Ing_soft3_backend'
          cliProjectName: 'Backend (Go)'
          extraProperties: |
            sonar.projectBaseDir=$(Build.SourcesDirectory)/Golang
            sonar.sources=.
            sonar.exclusions=**/vendor/**,**/tests/**
            sonar.go.coverage.reportPaths=coverage.out
            sonar.branch.name=$(Build.SourceBranchName)
            sonar.verbose=true
            sonar.scanner.dumpToFile=$(Build.SourcesDirectory)/scanner-props-back.txt

      - task: CmdLine@2
        displayName: "go tidy, tests (coverage) & build"
        inputs:
          script: |
            set -e
            cd Golang
            echo "go mod tidy"
            go mod tidy

            echo "‚ñ∂ go test con cobertura ‚Üí coverage.out"
            go test ./... -coverprofile=coverage.out -covermode=atomic

            echo "‚ñ∂ Genero coverage.html para verlo en el pipeline"
            go tool cover -html=coverage.out -o coverage.html
            go tool cover -func=coverage.out > coverage.txt

            echo "‚ñ∂ Build linux amd64"
            GOOS=linux GOARCH=amd64 go build -o ../app

      # (Opcional) Publicar cobertura HTML como artefacto navegable
      - task: PublishBuildArtifacts@1
        displayName: "Publicar coverage HTML (backend)"
        inputs:
          PathtoPublish: 'Golang/coverage.html'
          ArtifactName: 'back_coverage_html'
        condition: always()

      # Sonar: usa coverage.out indicado arriba (no necesita Cobertura XML)
      - task: SonarCloudAnalyze@2
        displayName: "Run SonarCloud Analysis (Backend)"

      - task: SonarCloudPublish@2
        displayName: "Publish SonarCloud Results (Backend)"
        condition: succeeded('Run_SonarCloud_Analysis_Backend')
        inputs:
          # --- ¬°CORREGIDO! SE ELIMIN√ì EL INPUT 'SonarCloud:' INV√ÅLIDO ---
          pollingTimeoutSec: '300'

      - task: ArchiveFiles@2
        displayName: "Zip backend binary"
        inputs:
          rootFolderOrFile: 'app'
          includeRootFolder: false
          archiveType: 'zip'
          archiveFile: '$(Build.ArtifactStagingDirectory)/backend.zip'
          replaceExistingArchive: true

      - task: PublishPipelineArtifact@1
        displayName: "Publish Backend Artifact"
        inputs:
          targetPath: '$(Build.ArtifactStagingDirectory)/backend.zip'
          artifactName: 'drop_back'

# ======================================================
# =         BUILD & PUSH DOCKER IMAGES                 =
# ======================================================
- stage: BuildAndPushImages
  displayName: "üê≥ Build & Push Docker Images"
  dependsOn: BuildAndTest
  condition: succeeded()
  jobs:
    - job: DockerBuildPush
      displayName: "Build & Push Backend and Frontend images"
      steps:
        - task: Docker@2
          displayName: "Build & Push Backend Image"
          inputs:
            command: buildAndPush
            containerRegistry: '$(acrConnection)'
            repository: '$(backendImage)'
            dockerfile: 'Golang/Dockerfile'
            buildContext: '.'
            tags: |
              latest
              $(Build.BuildId)

        - task: Docker@2
          displayName: "Build & Push Frontend Image"
          inputs:
            command: buildAndPush # <-- ¬°CORREGIDO!
            containerRegistry: '$(acrConnection)'
            repository: '$(frontendImage)'
            dockerfile: 'frontend/Dockerfile'
            buildContext: './frontend'
            tags: |
              latest
              $(Build.BuildId)

# ======================================================
# =                 DEPLOY QA                          =
# ======================================================
- stage: DeployQA
  displayName: "üöÄ Deploy to QA (Containers)"
  dependsOn: BuildAndPushImages
  jobs:
    - job: DeployContainersQA
      steps:
        - task: AzureWebAppContainer@1
          displayName: "Deploy Backend QA Container"
          inputs:
            azureSubscription: '$(azureSubscription)'
            appName: 'docker-backend-qa'
            containers: |
              $(acrLoginServer)/$(backendImage):latest

        - task: AzureWebAppContainer@1
          displayName: "Deploy Frontend QA Container"
          inputs:
            azureSubscription: '$(azureSubscription)'
            appName: 'docker-frontend-qa'
            containers: |
              $(acrLoginServer)/$(frontendImage):latest

# ======================================================
# =               E2E QA (Cypress)                     =
# ======================================================
- stage: E2E_QA
  displayName: "üß™ E2E Cypress contra QA"
  dependsOn: DeployQA
  condition: succeeded()
  jobs:
    - job: CypressRunQA
      displayName: "Run Cypress E2E (QA)"
      pool:
        name: MiPool
      steps:
        - task: NodeTool@0
          inputs:
            versionSpec: '16.x'
          displayName: "Set Node.js 16.x"

        - script: |
            set -e
            cd frontend
            echo "üì¶ Instalando deps para Cypress..."
            npm ci --no-audit --no-fund --legacy-peer-deps || npm install --no-audit --no-fund --legacy-peer-deps
            npx cypress verify
          displayName: "Install Cypress"

        - script: |
            set -e
            cd frontend
            echo "üöÄ Ejecutando Cypress headless contra QA..."
            rm -rf cypress/results || true
            mkdir -p cypress/results
            npx cypress run \
              --spec "cypress/e2e/test-*.cy.js" \
              --reporter junit \
              --reporter-options "mochaFile=cypress/results/junit-[hash].xml,toConsole=true" \
              --config baseUrl=https://$(webAppFrontendQA).azurewebsites.net,video=true,videoCompression=32
          displayName: "Run Cypress (headless, JUnit)"

        - task: PublishTestResults@2
          displayName: "Publicar resultados Cypress (JUnit)"
          inputs:
            testResultsFormat: 'JUnit'
            testResultsFiles: 'frontend/cypress/results/*.xml'
            mergeTestResults: true
            failTaskOnFailedTests: true

        - task: PublishPipelineArtifact@1
          displayName: "Adjuntar videos/screenshots Cypress"
          inputs:
            targetPath: 'frontend/cypress'
            artifactName: 'cypress_e2o_artifacts' # Note: 'e2o' might be a typo for 'e2e'

# ======================================================
# =                 DEPLOY PROD                        =
# ======================================================
- stage: DeployPROD
  displayName: "üöÄ Deploy to Production (Manual Approval)"
  dependsOn:
    - DeployQA
    - E2E_QA
  condition: succeeded()
  jobs:
    - deployment: DeployFrontendPROD
      displayName: "Deploy Frontend PROD"
      environment:
        name: 'PRODU'
      strategy:
        runOnce:
          deploy:
            steps:
              - task: DownloadPipelineArtifact@2
                displayName: 'Download Frontend PROD Artifact'
                inputs:
                  artifact: 'drop_front_prod'
                  path: '$(Pipeline.Workspace)/drop_front_prod'
              - task: AzureWebApp@1
                displayName: "Deploy Frontend to PROD Web App"
                inputs:
                  azureSubscription: '$(azureSubscription)'
                  appType: 'webApp'
                  appName: '$(webAppFrontendPROD)'
                  package: '$(Pipeline.Workspace)/drop_front_prod/frontend-prod.zip'

    - deployment: DeployBackendPROD
      displayName: "Deploy Backend PROD"
      environment:
        name: 'PRODU'
      strategy:
        runOnce:
          deploy:
            steps:
              - task: DownloadPipelineArtifact@2
                displayName: 'Download Backend Artifact'
                inputs:
                  artifact: 'drop_back'
                  path: '$(Pipeline.Workspace)/drop_back'
              - task: AzureWebApp@1
                displayName: "Deploy Backend to PROD Web App"
                inputs:
                  azureSubscription: '$(azureSubscription)'
                  appType: 'webApp'
                  appName: '$(webAppBackendPROD)'
                  package: '$(Pipeline.Workspace)/drop_back/backend.zip'
                  appSettings: |
                    -name WEBSITE_STARTUP_FILE -value ./app