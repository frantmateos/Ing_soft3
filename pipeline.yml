trigger:
  branches:
    include:
      - tomi

pool:
  name: MiPool

variables:
- name: azureSubscription
  value: 'tp05-connection'
- name: webAppFrontendQA
  value: 'webapp-QA-2025'
- name: webAppBackendQA
  value: 'BACKEND-QA-2025'
- name: REACT_APP_BACKEND_URL_QA
  value: 'https://backend-qa-2025.azurewebsites.net'
- name: webAppFrontendPROD
  value: 'webapp-PRODU-2025'
- name: webAppBackendPROD
  value: 'BACKEND-PRODU-2025'
- name: REACT_APP_BACKEND_URL_PROD
  value: 'https://backend-produ-2025.azurewebsites.net'
- name: acrLoginServer
  value: 'ingsoft3ucc.azurecr.io'
- name: acrConnection
  value: 'DockerServicee'
- name: backendImage
  value: 'backend'
- name: frontendImage
  value: 'frontend'

# SonarCloud
- name: sonarServiceConnection
  value: 'SonarCloud'
- name: sonarOrg
  value: 'frantmateos'
# =========================================================
# ‚ñº‚ñº ¬°¬°IMPORTANTE!! ‚ñº‚ñº
# Reemplaza estas keys por las keys REALES de tu proyecto monorepo en SonarCloud
# =========================================================
- name: sonarFrontProjectKey
  value: 'REEMPLAZA_CON_TU_KEY_DE_FRONTEND' 
- name: sonarFrontProjectName
  value: 'frontend'
- name: sonarBackProjectKey
  value: 'REEMPLAZA_CON_TU_KEY_DE_BACKEND'
- name: sonarBackProjectName
  value: 'backend'
# =========================================================
# ‚ñ≤‚ñ≤ FIN DE LA SECCI√ìN IMPORTANTE ‚ñ≤‚ñ≤
# =========================================================

stages:
# ===========================
# STAGE 1: BUILD & TEST
# ===========================
- stage: BuildAndTest
  displayName: "Build, Test Frontend & Backend"
  jobs:

  # ---------- FRONTEND QA ----------
  - job: BuildAndTestFrontQA
    displayName: "Build & Test Frontend (QA)"
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: '16.x'
      displayName: "Set Node.js version (16.x)"

    # Tarea de verificaci√≥n de Java (Sintaxis Mac/Linux)
    - task: CmdLine@2
      displayName: "Verify JAVA_HOME (Frontend)"
      inputs:
        script: |
          echo "--- VERIFICANDO JAVA ---"
          echo "Variable JAVA_HOME es: $JAVA_HOME"
          echo "Comando 'java -version':"
          java -version
          echo "--- FIN VERIFICACI√ìN ---"

    - task: CmdLine@2
      displayName: "Install, Test & Build Frontend for QA"
      inputs:
        script: |
          cd frontend
          echo "Node/npm:"
          node -v
          npm -v
          echo "REACT_APP_BACKEND_URL=${REACT_APP_BACKEND_URL_QA}" > .env
          echo "Usando .env:" && cat .env
          echo "Config npm para CI robusto"
          npm config set engine-strict false
          npm config set legacy-peer-deps true
          npm config set audit false
          npm config set fund false
          echo "üì¶ npm ci (fallback a npm install si falla)"
          if ! npm ci --no-audit --no-fund --legacy-peer-deps --unsafe-perm; then
            echo "npm ci fall√≥. Fallback a npm install limpio‚Ä¶"
            rm -rf node_modules package-lock.json
            npm install --no-audit --no-fund --legacy-peer-deps --unsafe-perm
          fi
          echo "üß™ Tests (fallan si hay errores reales)"
          npm test -- --watchAll=false
          echo "üåç Build QA sin cortar por warnings (CI=false + sin ESLint en build)"
          CI=false DISABLE_ESLINT_PLUGIN=true npm run build
          echo "üß© Agrego server de Node para Azure App Service"
          cat > build/server.js <<'EOF'
          const express = require("express");
          const path = require("path");
          const compression = require("compression");
          const app = express();
          const port = process.env.PORT || 8080;
          app.use(compression());
          app.use(express.static(path.join(__dirname)));
          app.get("*", (_, res) => res.sendFile(path.join(__dirname, "index.html")));
          app.listen(port, () => console.log(`‚úÖ Frontend running on port ${port}`));
          EOF
          cat > build/package.json <<'EOF'
          {
            "name": "frontend-spa",
            "version": "1.0.0",
            "scripts": { "start": "node server.js" },
            "dependencies": {
              "express": "^4.18.2",
              "compression": "^1.7.4"
            }
          }
          EOF
          cd build
          npm install --production --no-audit --no-fund

    # --- Coverage de Jest + publicar en Azure DevOps ---
    - script: |
        cd frontend
        echo "üß™ Ejecutando Jest con coverage (lcov + cobertura)..."
        npm test -- --coverage --watchAll=false --coverageReporters=lcov --coverageReporters=cobertura
        echo "üìÇ Archivos generados en coverage:"
        ls -lah coverage || dir coverage
        echo "Primeras l√≠neas del lcov.info:"
        head -n 10 coverage/lcov.info || echo "lcov.info no encontrado"
      displayName: "Run Jest with Coverage"

    - task: PublishCodeCoverageResults@2
      displayName: "Publish Frontend Coverage (Cobertura)"
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: 'frontend/coverage/cobertura-coverage.xml'
        reportDirectory: 'frontend/coverage'
        failIfCoverageEmpty: false

    - script: |
        echo "üîç DEBUG: verificando cobertura FRONTEND"
        echo "Directorio actual: $(pwd)"
        ls -R frontend/coverage || echo "No existe carpeta coverage"
        echo "Primeras l√≠neas del lcov.info:"
        head -n 20 frontend/coverage/lcov.info || echo "No existe lcov.info"
      displayName: "DEBUG Coverage Frontend antes de Sonar"

    # --- Normalizar rutas del lcov (si hiciera falta) ---
    - script: |
        if [ -f frontend/coverage/lcov.info ]; then
          cd frontend/coverage
          echo "üß© Normalizando rutas absolutas -> relativas en lcov.info (si aplica)"
          # Correcci√≥n para sed en macOS
          sed -i '' 's|/Users/.*/frontend/src|frontend/src|g' lcov.info || true
          head -n 10 lcov.info || true
        fi
      displayName: "Fix lcov.info paths for SonarCloud"

    # --- SonarCloud del FRONTEND ---
    - task: SonarCloudPrepare@3
      displayName: "SonarCloud Prepare (Frontend)"
      inputs:
        SonarQube: '$(sonarServiceConnection)'
        organization: '$(sonarOrg)'
        scannerMode: 'CLI'
        configMode: 'manual'
        cliProjectKey: '$(sonarFrontProjectKey)' # <-- Usa la nueva key
        cliProjectName: '$(sonarFrontProjectName)'
        cliSources: 'frontend/src'
        cliOptions: >
          -Dsonar.javascript.lcov.reportPaths=$(Build.SourcesDirectory)/frontend/coverage/lcov.info
          -Dsonar.exclusions=**/node_modules/**,**/*.test.*,**/__mocks__/**

    - task: SonarCloudAnalyze@3
      displayName: "SonarCloud Analyze (Frontend)"
      inputs:
        jdkversion: 'JAVA_HOME' # <-- Esto usa la variable del agente

    - task: SonarCloudPublish@3
      displayName: "SonarCloud Publish (Frontend, Quality Gate)"
      inputs:
        pollingTimeoutSec: '300'

    - task: ArchiveFiles@2
      displayName: "Zip Frontend QA build"
      inputs:
        rootFolderOrFile: 'frontend/build'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)/frontend-qa.zip'
        replaceExistingArchive: true

    - task: PublishPipelineArtifact@1
      displayName: "Publish Frontend QA Artifact"
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)/frontend-qa.zip'
        artifactName: 'drop_front_qa'

  # ---------- FRONTEND PROD ----------
  - job: BuildFrontPROD
    displayName: "Build Frontend (Production)"
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: '16.x'
      displayName: "Set Node.js version (16.x)"

    - task: CmdLine@2
      displayName: "Build Frontend for Production"
      inputs:
        script: |
          set -e
          cd frontend
          echo "üåç Building React app for Production..."
          echo "REACT_APP_BACKEND_URL=${REACT_APP_BACKEND_URL_PROD}" > .env
          cat .env
          npm install
          npm run build
          echo "üß© Adding Node server for Azure..."
          cat > build/server.js <<'EOF'
          const express = require("express");
          const path = require("path");
          const compression = require("compression");
          const app = express();
          const port = process.env.PORT || 8080;
          app.use(compression());
          app.use(express.static(path.join(__dirname)));
          app.get("*", (_, res) => res.sendFile(path.join(__dirname, "index.html")));
          app.listen(port, () => console.log(`‚úÖ Frontend running on port ${port}`));
          EOF
          cat > build/package.json <<'EOF'
          {
            "name": "frontend-spa",
            "version": "1.0.0",
            "scripts": { "start": "node server.js" },
            "dependencies": {
              "express": "^4.18.2",
              "compression": "^1.7.4"
            }
          }
          EOF
          cd build
          npm install --production

    - task: ArchiveFiles@2
      displayName: "Zip Frontend PROD build"
      inputs:
        rootFolderOrFile: 'frontend/build'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)/frontend-prod.zip'
        replaceExistingArchive: true

    - task: PublishPipelineArtifact@1
      displayName: "Publish Frontend PROD Artifact"
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)/frontend-prod.zip'
        artifactName: 'drop_front_prod'

  # ---------- BACKEND (Go) ----------
  - job: BuildAndTestBack
    displayName: "Build & Test Backend (Go)"
    steps:

    - checkout: self
      fetchDepth: 0

    - task: GoTool@0
      inputs:
        version: '1.22.1'
      displayName: "Use Go version"
      
    # Tarea de verificaci√≥n de Java (Sintaxis Mac/Linux)
    - task: CmdLine@2
      displayName: "Verify JAVA_HOME (Backend)"
      inputs:
        script: |
          echo "--- VERIFICANDO JAVA ---"
          echo "Variable JAVA_HOME es: $JAVA_HOME"
          echo "Comando 'java -version':"
          java -version
          echo "--- FIN VERIFICACI√ìN ---"

    # SonarCloud PREPARE (Backend)
    - task: SonarCloudPrepare@3
      displayName: "SonarCloud Prepare (Backend)"
      inputs:
        SonarQube: '$(sonarServiceConnection)'
        organization: '$(sonarOrg)'
        scannerMode: 'CLI'
        configMode: 'manual'
        cliProjectKey: '$(sonarBackProjectKey)' # <-- Usa la nueva key
        cliProjectName: '$(sonarBackProjectName)'
        cliSources: 'Golang'
        cliOptions: >
          -Dsonar.exclusions=**/vendor/**,**/tests/**
          -Dsonar.language=go
          -Dsonar.go.coverage.reportPaths=$(Build.SourcesDirectory)/Golang/coverage.out

    - task: CmdLine@2
      displayName: "Tidy, Test & Build Backend"
      inputs:
        script: |
          cd Golang
          echo "üì¶ Tidying Go modules..."
          go mod tidy
          echo "üß™ Running Go tests..."
          go test ./... -coverprofile=coverage.out -covermode=atomic
          echo "Verificando cobertura Go..."
          ls -lah
          head -n 10 coverage.out || echo "No existe coverage.out"
          echo "üî® Building Go binary for Linux..."
          GOOS=linux GOARCH=amd64 go build -o ../app
        failOnStderr: true

    - task: PublishCodeCoverageResults@2
      displayName: "üìä Publish Backend Coverage (Go)"
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: 'Golang/coverage.out'
        reportDirectory: 'Golang'
        failIfCoverageEmpty: false

    - script: |
        echo "üîç DEBUG: verificando cobertura BACKEND"
        echo "Directorio actual: $(pwd)"
        ls -lah Golang || echo "No existe carpeta Golang"
        echo "Primeras l√≠neas del coverage.out:"
        head -n 20 Golang/coverage.out || echo "No existe coverage.out"
      displayName: "DEBUG Coverage Backend antes de Sonar"

    - task: SonarCloudAnalyze@3
      displayName: "Run SonarCloud Analysis (Backend)"
      inputs:
        jdkversion: 'JAVA_HOME' # <-- Esto usa la variable del agente

    - task: SonarCloudPublish@3
      displayName: "Publish SonarCloud Results (Backend)"
      inputs:
        pollingTimeoutSec: '300'

    - task: ArchiveFiles@2
      displayName: "Zip backend binary"
      inputs:
        rootFolderOrFile: 'app'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)/backend.zip'
        replaceExistingArchive: true

    - task: PublishPipelineArtifact@1
      displayName: "Publish Backend Artifact"
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)/backend.zip'
        artifactName: 'drop_back'

# ===========================
# STAGE 2: BUILD & PUSH IMAGES
# ===========================
- stage: BuildAndPushImages
  displayName: "üê≥ Build & Push Docker Images"
  dependsOn: BuildAndTest
  condition: succeeded()
  jobs:
  - job: DockerBuildPush
    displayName: "Build & Push Backend and Frontend images"
    steps:
    - task: Docker@2
      displayName: "Build & Push Backend Image"
      inputs:
        command: buildAndPush
        containerRegistry: '$(acrConnection)'
        repository: '$(backendImage)'
        dockerfile: 'Golang/Dockerfile'
        buildContext: '.'
        tags: |
          latest
          $(Build.BuildId)

    - task: Docker@2
      displayName: "Build & Push Frontend Image"
      inputs:
        command: buildAndPush
        containerRegistry: '$(acrConnection)'
        repository: '$(frontendImage)'
        dockerfile: 'frontend/Dockerfile'
        buildContext: './frontend'
        tags: |
          latest
          $(Build.BuildId)

# ===========================
# STAGE 3: DEPLOY QA
# ===========================
- stage: DeployQA
  displayName: "üöÄ Deploy to QA (Containers)"
  dependsOn: BuildAndPushImages
  jobs:
  - job: DeployContainersQA
    steps:
    - task: AzureWebAppContainer@1
      displayName: "Deploy Backend QA Container"
      inputs:
        azureSubscription: '$(azureSubscription)'
        appName: 'docker-backend-qa'
        containers: |
          $(acrLoginServer)/$(backendImage):latest

    - task: AzureWebAppContainer@1
      displayName: "Deploy Frontend QA Container"
      inputs:
        azureSubscription: '$(azureSubscription)'
        appName: 'docker-frontend-qa'
        containers: |
          $(acrLoginServer)/$(frontendImage):latest

# ===========================
# STAGE 2.5: E2E QA (Cypress)
# ===========================
- stage: E2E_QA
  displayName: "üß™ E2E Cypress contra QA"
  dependsOn:
    - DeployQA
  condition: succeeded()
  jobs:
  - job: CypressRunQA
    displayName: "Run Cypress E2E (QA)"
    pool:
      name: MiPool
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: '16.x'
      displayName: "Set Node.js 16.x"

    - script: |
        cd frontend
        echo "üì¶ Instalando deps para Cypress..."
        npm ci --no-audit --no-fund --legacy-peer-deps || npm install --no-audit --no-fund --legacy-peer-deps
        npx cypress verify
      displayName: "Install Cypress"

    - script: |
        cd frontend
        echo "üöÄ Ejecutando Cypress headless contra QA..."
        rm -rf cypress/results || true
        mkdir -p cypress/results
        npx cypress run \
          --spec "cypress/e2e/test-*.cy.js" \
          --reporter junit \
          --reporter-options "mochaFile=cypress/results/junit-[hash].xml,toConsole=true" \
          --config baseUrl=https://$(webAppFrontendQA).azurewebsites.net,video=true,videoCompression=32
      displayName: "Run Cypress (headless, JUnit)"

    - task: PublishTestResults@2
      displayName: "Publicar resultados Cypress (JUnit)"
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: 'frontend/cypress/results/*.xml'
        mergeTestResults: true
        failTaskOnFailedTests: true

    - task: PublishBuildArtifacts@1
      displayName: "Adjuntar videos/screenshots Cypress"
      inputs:
        pathToPublish: 'frontend/cypress'
        artifactName: 'cypress_e2e_artifacts'
        publishLocation: 'Container'

# ===========================
# STAGE 4: DEPLOY PROD
# ===========================
- stage: DeployPROD
  displayName: "üöÄ Deploy to Production (Manual Approval)"
  dependsOn:
    - DeployQA
    - E2E_QA
  condition: succeeded()
  jobs:
  - deployment: DeployFrontendPROD
    displayName: "Deploy Frontend PROD"
    environment:
      name: 'PRODU'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: DownloadPipelineArtifact@2
            displayName: 'Download Frontend PROD Artifact'
            inputs:
              artifact: 'drop_front_prod'
              path: '$(Pipeline.Workspace)/drop_front_prod'
          - task: AzureWebApp@1
            displayName: "Deploy Frontend to PROD Web App"
            inputs:
              azureSubscription: '$(azureSubscription)'
              appType: 'webApp'
              appName: '$(webAppFrontendPROD)'
              package: '$(Pipeline.Workspace)/drop_front_prod/frontend-prod.zip'

  - deployment: DeployBackendPROD
    displayName: "Deploy Backend PROD"
    environment:
      name: 'PRODU'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: DownloadPipelineArtifact@2
            displayName: 'Download Backend Artifact'
            inputs:
              artifact: 'drop_back'
              path: '$(Pipeline.Workspace)/drop_back'
          - task: AzureWebApp@1
            displayName: "Deploy Backend to PROD Web App"
            inputs:
              azureSubscription: '$(azureSubscription)'
              appType: 'webApp'
              appName: '$(webAppBackendPROD)'
              package: '$(Pipeline.Workspace)/drop_back/backend.zip'
              appSettings: |
                -name WEBSITE_STARTUP_FILE -value ./app