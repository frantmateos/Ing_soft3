trigger:
  branches:
    include:
      - Task-1

pool:
  name: MiPool

variables:
- name: azureSubscription
  value: 'tp05-connection'
- name: webAppFrontendQA
  value: 'webapp-QA-2025'
- name: webAppBackendQA
  value: 'BACKEND-QA-2025'
- name: REACT_APP_BACKEND_URL_QA
  value: 'https://backend-qa-2025.azurewebsites.net'
- name: webAppFrontendPROD
  value: 'webapp-PRODU-2025'
- name: webAppBackendPROD
  value: 'BACKEND-PRODU-2025'
- name: REACT_APP_BACKEND_URL_PROD
  value: 'https://backend-produ-2025.azurewebsites.net'
- name: acrLoginServer
  value: 'ingsoft3ucc.azurecr.io'
- name: acrConnection
  value: 'DockerServicee'
- name: backendImage
  value: 'backend'
- name: frontendImage
  value: 'frontend'


stages:
# ===========================
# STAGE 1: BUILD & TEST
# ===========================
- stage: BuildAndTest
  displayName: "Build, Test Frontend & Backend"
  jobs:

  # ---------- FRONTEND QA (simple y robusto) ----------
  - job: BuildAndTestFrontQA
    displayName: "Build & Test Frontend (QA)"
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: '16.x'
      displayName: "Set Node.js version (16.x)"

    - task: CmdLine@2
      displayName: "Install, Test & Build Frontend for QA"
      inputs:
        script: |
          cd frontend

          echo "Node/npm:"
          node -v
          npm -v

          # Solo la variable que necesita tu app
          echo "REACT_APP_BACKEND_URL=${REACT_APP_BACKEND_URL_QA}" > .env
          echo "Usando .env:" && cat .env

          echo "Config npm para CI robusto"
          npm config set engine-strict false
          npm config set legacy-peer-deps true
          npm config set audit false
          npm config set fund false

          echo "üì¶ npm ci (fallback a npm install si falla)"
          if ! npm ci --no-audit --no-fund --legacy-peer-deps --unsafe-perm; then
            echo "npm ci fall√≥. Fallback a npm install limpio‚Ä¶"
            rm -rf node_modules package-lock.json
            npm install --no-audit --no-fund --legacy-peer-deps --unsafe-perm
          fi

          echo "üß™ Tests (fallan si hay errores reales)"
          npm test -- --watchAll=false

          echo "üåç Build QA sin cortar por warnings (CI=false + sin ESLint en build)"
          CI=false DISABLE_ESLINT_PLUGIN=true npm run build

          echo "üß© Agrego server de Node para Azure App Service"
          cat > build/server.js <<'EOF'
          const express = require("express");
          const path = require("path");
          const compression = require("compression");
          const app = express();
          const port = process.env.PORT || 8080;
          app.use(compression());
          app.use(express.static(path.join(__dirname)));
          app.get("*", (_, res) => res.sendFile(path.join(__dirname, "index.html")));
          app.listen(port, () => console.log(`‚úÖ Frontend running on port ${port}`));
          EOF

          cat > build/package.json <<'EOF'
          {
            "name": "frontend-spa",
            "version": "1.0.0",
            "scripts": { "start": "node server.js" },
            "dependencies": {
              "express": "^4.18.2",
              "compression": "^1.7.4"
            }
          }
          EOF

          cd build
          npm install --production --no-audit --no-fund

    # --- üîé Coverage de Jest + publicar en Azure DevOps ---
    - script: |
        cd frontend
        echo "üß™ Ejecutando Jest con coverage (lcov + cobertura)..."
        npm test -- --coverage --watchAll=false --coverageReporters=lcov --coverageReporters=cobertura
        echo "üìÇ Archivos generados en coverage:"
        ls -lah coverage
        echo "Primeras l√≠neas del lcov.info:"
        head -n 10 coverage/lcov.info || echo "lcov.info no encontrado"
      displayName: "Run Jest with Coverage"

    - task: PublishCodeCoverageResults@2
      displayName: "Publish Frontend Coverage (Cobertura)"
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: 'frontend/coverage/cobertura-coverage.xml'
        reportDirectory: 'frontend/coverage'
        failIfCoverageEmpty: false

    - script: |
        echo "üîç DEBUG: verificando cobertura FRONTEND"
        echo "Directorio actual: $(pwd)"
        ls -R frontend/coverage || echo "No existe carpeta coverage"
        echo "Primeras l√≠neas del lcov.info:"
        head -n 20 frontend/coverage/lcov.info || echo "No existe lcov.info"
      displayName: "DEBUG Coverage Frontend antes de Sonar"

    # --- üß≠ SonarCloud del FRONTEND ---

    - script: |
        cd frontend/coverage
        echo "üß© Normalizando rutas absolutas -> relativas en lcov.info"
        sed -i '' "s|/Users/franciscomateos/myagent/_work/1/s/frontend/src|frontend/src|g" lcov.info
        head -n 10 lcov.info
      displayName: "Fix lcov.info paths for SonarCloud"

    - task: SonarCloudPrepare@3
      displayName: "SonarCloud Prepare (Frontend)"
      inputs:
        SonarQube: 'SonarCloud'
        organization: 'frantmateos'              # <--- TU ORG
        scannerMode: 'CLI'
        configMode: 'manual'
        cliProjectKey: 'frantmateos_frontend_qa' # <--- PROJECT KEY FRONTEND
        cliProjectName: 'frontend-qa'
        cliSources: 'frontend/src'
        cliOptions: >
          -Dsonar.javascript.lcov.reportPaths=$(Build.SourcesDirectory)/frontend/coverage/lcov.info
          -Dsonar.exclusions=**/node_modules/**,**/*.test.*,**/__mocks__/**
    

    - task: SonarCloudAnalyze@3
      displayName: "SonarCloud Analyze (Frontend)"

    - task: SonarCloudPublish@3
      displayName: "SonarCloud Publish (Frontend, Quality Gate)"
      inputs:
        pollingTimeoutSec: '300'

    - task: ArchiveFiles@2
      displayName: "Zip Frontend QA build"
      inputs:
        rootFolderOrFile: 'frontend/build'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)/frontend-qa.zip'
        replaceExistingArchive: true

    - task: ecdc45f6-832d-4ad9-b52b-ee49e94659be@1
      displayName: "Publish Frontend QA Artifact"
      inputs:
        path: $(Build.ArtifactStagingDirectory)/frontend-qa.zip
        artifactName: drop_front_qa

  # ---------- FRONTEND PROD (sin cambios extra) ----------
  - job: BuildFrontPROD
    displayName: "Build Frontend (Production)"
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: '16.x'
      displayName: "Set Node.js version (16.x)"

    - task: CmdLine@2
      displayName: "Build Frontend for Production"
      inputs:
        script: |
          set -e
          cd frontend
          echo "üåç Building React app for Production..."
          echo "REACT_APP_BACKEND_URL=${REACT_APP_BACKEND_URL_PROD}" > .env
          cat .env
          npm install
          npm run build

          echo "üß© Adding Node server for Azure..."
          cat > build/server.js <<'EOF'
          const express = require("express");
          const path = require("path");
          const compression = require("compression");
          const app = express();
          const port = process.env.PORT || 8080;
          app.use(compression());
          app.use(express.static(path.join(__dirname)));
          app.get("*", (_, res) => res.sendFile(path.join(__dirname, "index.html")));
          app.listen(port, () => console.log(`‚úÖ Frontend running on port ${port}`));
          EOF

          cat > build/package.json <<'EOF'
          {
            "name": "frontend-spa",
            "version": "1.0.0",
            "scripts": { "start": "node server.js" },
            "dependencies": {
              "express": "^4.18.2",
              "compression": "^1.7.4"
            }
          }
          EOF

          cd build
          npm install --production

    - task: ArchiveFiles@2
      displayName: "Zip Frontend PROD build"
      inputs:
        rootFolderOrFile: 'frontend/build'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)/frontend-prod.zip'
        replaceExistingArchive: true

    - task: ecdc45f6-832d-4ad9-b52b-ee49e94659be@1
      displayName: "Publish Frontend PROD Artifact"
      inputs:
        path: $(Build.ArtifactStagingDirectory)/frontend-prod.zip
        artifactName: drop_front_prod

  # ---------- BACKEND (Go) ----------
  - job: BuildAndTestBack
    displayName: "Build & Test Backend (Go)"
    steps:

    - checkout: self
      fetchDepth: 0

    - task: GoTool@0
      inputs:
        version: '1.22.1'
      displayName: "Use Go version"

    - task: SonarCloudPrepare@3
      inputs:
        SonarQube: 'SonarCloud'
        organization: 'frantmateos'
        scannerMode: 'CLI'
        configMode: 'manual'
        cliProjectKey: 'frantmateos_Ing_soft3'
        cliProjectName: 'Ing_soft3'
        cliSources: 'Golang'
        cliOptions: >
          -Dsonar.exclusions=**/vendor/**,**/tests/**
          -Dsonar.language=go
          -Dsonar.go.coverage.reportPaths=$(Build.SourcesDirectory)/Golang/coverage.out

    - task: CmdLine@2
      displayName: "Tidy, Test & Build Backend"
      inputs:
        script: |
          cd Golang
          echo "üì¶ Tidying Go modules..."
          go mod tidy
          echo "üß™ Running Go tests..."
          go test ./... -coverprofile=coverage.out -covermode=atomic
          echo "Verificando cobertura Go..."
          ls -lah
          head -n 10 coverage.out || echo "No existe coverage.out"
          mv coverage.out ../Golang/coverage.out
          echo "üî® Building Go binary for Linux..."
          GOOS=linux GOARCH=amd64 go build -o ../app
        failOnStderr: true

    - script: |
        echo "‚òï Setting Java 17 environment variables..."
        JAVA_PATH=$(/usr/libexec/java_home -v 17)
        echo "##vso[task.setvariable variable=JAVA_HOME]$JAVA_PATH"
        echo "##vso[task.setvariable variable=PATH]$JAVA_PATH/bin:$PATH"
        java -version
      displayName: "Configure Java 17 for SonarCloud"

    - task: PublishCodeCoverageResults@2
      displayName: "üìä Publish Backend Coverage (Go)"
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: 'Golang/coverage.out'
        reportDirectory: 'Golang'
        failIfCoverageEmpty: false

    - script: |
        echo "üîç DEBUG: verificando cobertura BACKEND"
        echo "Directorio actual: $(pwd)"
        ls -lah Golang || echo "No existe carpeta Golang"
        echo "Primeras l√≠neas del coverage.out:"
        head -n 20 Golang/coverage.out || echo "No existe coverage.out"
      displayName: "DEBUG Coverage Backend antes de Sonar"

    - task: SonarCloudAnalyze@3
      displayName: "Run SonarCloud Analysis"
      inputs:
        jdkversion: 'JAVA_HOME_17_X64'

    - task: SonarCloudPublish@3
      displayName: "Publish SonarCloud Results"
      inputs:
        pollingTimeoutSec: '300'

    - task: ArchiveFiles@2
      displayName: "Zip backend binary"
      inputs:
        rootFolderOrFile: 'app'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)/backend.zip'
        replaceExistingArchive: true

    - task: ecdc45f6-832d-4ad9-b52b-ee49e94659be@1
      displayName: "Publish Backend Artifact"
      inputs:
        path: $(Build.ArtifactStagingDirectory)/backend.zip
        artifactName: drop_back

# ===========================
# STAGE 2: BUILD & PUSH IMAGES
# ===========================
- stage: BuildAndPushImages
  displayName: "üê≥ Build & Push Docker Images"
  dependsOn: BuildAndTest
  condition: succeeded()
  jobs:
  - job: DockerBuildPush
    displayName: "Build & Push Backend and Frontend images"
    steps:
    - script: |
        echo "üß© DEBUG: Contenido del contexto Docker antes del build"
        ls -R Golang | head -n 50
        echo "Dockerfile:"
        cat Golang/Dockerfile | head -n 30
      displayName: "Verificar contenido Docker antes del build"

    - task: Docker@2
      displayName: "Build & Push Backend Image"
      inputs:
        command: buildAndPush
        containerRegistry: '$(acrConnection)'
        repository: '$(backendImage)'
        dockerfile: 'Golang/Dockerfile'
        buildContext: '.'
        tags: |
          latest
          $(Build.BuildId)
        arguments: '--no-cache'

    
    - script: |
        echo "‚úÖ Imagenes en local despu√©s del build:"
        docker images | grep backend || echo "No se encontr√≥ imagen backend"
      displayName: "Listar im√°genes locales (post-build)"


    - task: Docker@2
      displayName: "Build & Push Frontend Image"
      inputs:
        command: buildAndPush
        containerRegistry: '$(acrConnection)'
        repository: '$(frontendImage)'
        dockerfile: 'frontend/Dockerfile'
        buildContext: './frontend'
        buildArguments: |
          REACT_APP_BACKEND_URL=http://backend-instance-qa.brazilsouth.azurecontainer.io:8081
        tags: |
          latest
          $(Build.BuildId)
        arguments: '--platform linux/amd64 --no-cache'

- stage: DeployToACI
  displayName: "üöÄ Deploy Backend QA to Azure Container Instance"
  dependsOn: BuildAndPushImages
  jobs:
  - job: DeployBackendACI
    pool:
      vmImage: ubuntu-latest
    steps:
    - task: AzureCLI@2
      displayName: "Deploy Backend Container to ACI"
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          echo "Deploying backend container to Azure Container Instance (ACI)..."

          # üîπ Borrar si ya existe
          az container delete \
            --resource-group TP5-2025 \
            --name backend-instance-qa \
            --yes || true

          # üîπ Crear nuevo contenedor
          az container create \
            --resource-group TP5-2025 \
            --name backend-instance-qa \
            --image $(acrLoginServer)/$(backendImage):latest \
            --dns-name-label backend-instance-qa \
            --ports 8081 \
            --os-type Linux \
            --registry-login-server $(acrLoginServer) \
            --registry-username IngSoft3UCC \
            --registry-password $(AZURE_ACR_PASSWORD) \
            --environment-variables \
              PORT=8081 \
              ENVIRONMENT=QA \
              DB_HOST=mysql-server-2025.mysql.database.azure.com \
              DB_NAME=tp05_qa \
              DB_USER=adminqa \
              DB_PASS=Tomas1927 \
            --cpu 1 \
            --memory 1.5 \
            --restart-policy Always

- stage: DeployFrontendACI
  displayName: "üöÄ Deploy Frontend QA to Azure Container Instance"
  dependsOn: BuildAndPushImages
  jobs:
  - job: DeployFrontendACI
    pool:
      vmImage: ubuntu-latest
    steps:
    - task: AzureCLI@2
      displayName: "Deploy Frontend Container to ACI"
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          echo "Deploying frontend container to Azure Container Instance (ACI)..."

          # üîπ Eliminar si ya existe
          az container delete \
            --resource-group TP5-2025 \
            --name frontend-instance-qa \
            --yes || true

          # üîπ Crear nuevo contenedor para el frontend
          az container create \
            --resource-group TP5-2025 \
            --name frontend-instance-qa \
            --image $(acrLoginServer)/$(frontendImage):latest \
            --dns-name-label frontend-instance-qa \
            --ip-address Public \
            --ports 80 \
            --os-type Linux \
            --registry-login-server $(acrLoginServer) \
            --registry-username IngSoft3UCC \
            --registry-password $(AZURE_ACR_PASSWORD) \
            --cpu 1 \
            --memory 1.0 \
            --restart-policy Always




# ===========================
# STAGE 3: DEPLOY QA
# ===========================
- stage: DeployQA
  displayName: "üöÄ Deploy to QA (Containers)"
  dependsOn: BuildAndPushImages
  jobs:
  - job: DeployContainersQA
    steps:
    - task: AzureWebAppContainer@1
      displayName: "Deploy Backend QA Container"
      inputs:
        azureSubscription: '$(azureSubscription)'
        appName: 'docker-backend-qa'
        containers: |
          $(acrLoginServer)/$(backendImage):latest

    - task: AzureWebAppContainer@1
      displayName: "Deploy Frontend QA Container"
      inputs:
        azureSubscription: '$(azureSubscription)'
        appName: 'docker-frontend-qa'
        containers: |
          $(acrLoginServer)/$(frontendImage):latest
# ===========================
# STAGE 2.5: E2E QA (Cypress)
# ===========================
- stage: E2E_QA
  displayName: "üß™ E2E Cypress contra QA"
  dependsOn:
    - DeployQA
  condition: succeeded()
  jobs:
  - job: CypressRunQA
    displayName: "Run Cypress E2E (QA)"
    pool:
      name: MiPool
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: '16.x'
      displayName: "Set Node.js 16.x"

    - script: |
        cd frontend
        echo "üì¶ Instalando deps para Cypress..."
        npm ci --no-audit --no-fund --legacy-peer-deps || npm install --no-audit --no-fund --legacy-peer-deps
        npx cypress verify
      displayName: "Install Cypress"

    - script: |
        cd frontend
        echo "üöÄ Ejecutando Cypress headless contra QA..."
        rm -rf cypress/results || true
        mkdir -p cypress/results
        npx cypress run \
          --spec "cypress/e2e/test-*.cy.js" \
          --reporter junit \
          --reporter-options "mochaFile=cypress/results/junit-[hash].xml,toConsole=true" \
          --config baseUrl=https://$(webAppFrontendQA).azurewebsites.net,video=true,videoCompression=32
      displayName: "Run Cypress (headless, JUnit)"


    - task: PublishTestResults@2
      displayName: "Publicar resultados Cypress (JUnit)"
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: 'frontend/cypress/results/*.xml'
        mergeTestResults: true
        failTaskOnFailedTests: true

    - task: PublishBuildArtifacts@1
      displayName: "Adjuntar videos/screenshots Cypress"
      inputs:
        pathToPublish: 'frontend/cypress'
        artifactName: 'cypress_e2e_artifacts'
        publishLocation: 'Container'

# ===========================
# STAGE 3: DEPLOY PROD
# ===========================
- stage: DeployPROD
  displayName: "üöÄ Deploy to Production (Manual Approval)"
  dependsOn:
    - DeployQA
    - E2E_QA
  condition: succeeded()
  jobs:
  - deployment: DeployFrontendPROD
    displayName: "Deploy Frontend PROD"
    environment:
      name: 'PRODU'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: 30f35852-3f7e-4c0c-9a88-e127b4f97211@1
            inputs:
              alias: current
              artifact: drop_front_prod
          - task: AzureWebApp@1
            displayName: "Deploy Frontend to PROD Web App"
            inputs:
              azureSubscription: '$(azureSubscription)'
              appType: 'webApp'
              appName: '$(webAppFrontendPROD)'
              package: '$(Pipeline.Workspace)/drop_front_prod/frontend-prod.zip'

  - deployment: DeployBackendPROD
    displayName: "Deploy Backend PROD"
    environment:
      name: 'PRODU'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: 30f35852-3f7e-4c0c-9a88-e127b4f97211@1
            inputs:
              alias: current
              artifact: drop_back
          - task: AzureWebApp@1
            displayName: "Deploy Backend to PROD Web App"
            inputs:
              azureSubscription: '$(azureSubscription)'
              appType: 'webApp'
              appName: '$(webAppBackendPROD)'
              package: '$(Pipeline.Workspace)/drop_back/backend.zip'
              appSettings: |
                -name WEBSITE_STARTUP_FILE -value ./app
