trigger:
  branches:
    include:
      - main

pool:
  name: MiPool  # o usar 'vmImage: "ubuntu-latest"'

variables:
  azureSubscription: 'tp05-connection'
  # ... (tus otras variables QA/PROD) ...
  webAppFrontendQA: 'webapp-QA-2025'
  webAppBackendQA: 'BACKEND-QA-2025'
  REACT_APP_BACKEND_URL_QA: 'https://backend-qa-2025.azurewebsites.net'
  webAppFrontendPROD: 'webapp-PRODU-2025'
  webAppBackendPROD: 'BACKEND-PRODU-2025'
  REACT_APP_BACKEND_URL_PROD: 'https://backend-produ-2025.azurewebsites.net'

stages:
  # ===========================
  # STAGE 1: BUILD & TEST FRONT & BACK  ### <<< MODIFICADO >>> ###
  # ===========================
  - stage: BuildAndTest  ### <<< MODIFICADO >>> ###
    displayName: "Build, Test Frontend & Backend" ### <<< MODIFICADO >>> ###
    jobs:

      # ---------- BUILD & TEST FRONTEND QA ---------- ### <<< MODIFICADO >>> ###
      - job: BuildAndTestFrontQA ### <<< MODIFICADO >>> ###
        displayName: "Build & Test Frontend (QA)" ### <<< MODIFICADO >>> ###
        steps:
          - task: NodeTool@0
            inputs:
              versionSpec: '18.x' 
            displayName: "Set Node.js version (18.x)"

          - script: |
              set -e
              cd frontend
              echo "ðŸ“¦ Installing frontend dependencies..."
              npm install

              echo "ðŸ§ª Running frontend tests..."
              # ### <<< AÃ‘ADIDO >>> ### Ejecutamos los tests
              npm test -- --watchAll=false 

              echo "ðŸŒ Building React app for QA..."
              echo "REACT_APP_BACKEND_URL=$(REACT_APP_BACKEND_URL_QA)" > .env
              cat .env
              npm run build

              echo "ðŸ§© Adding Node server for Azure..."
              cat > build/server.js <<'EOF'
              const express = require("express");
              const path = require("path");
              const compression = require("compression");
              const app = express();
              const port = process.env.PORT || 8080;
              app.use(compression());
              app.use(express.static(path.join(__dirname)));
              app.get("*", (_, res) => res.sendFile(path.join(__dirname, "index.html")));
              app.listen(port, () => console.log(`âœ… Frontend running on port ${port}`));
              EOF
              cat > build/package.json <<'EOF'
              {
                "name": "frontend-spa",
                "version": "1.0.0",
                "scripts": { "start": "node server.js" },
                "dependencies": {
                  "express": "^4.18.2",
                  "compression": "^1.7.4"
                }
              }
              EOF
              cd build
              npm install --production
            displayName: "Install, Test & Build Frontend for QA" 
            # ### <<< AÃ‘ADIDO >>> ### Asegura que el pipeline falle si 'npm test' falla
            failOnStderr: true 

          - task: ArchiveFiles@2
            displayName: "Zip Frontend QA build"
            inputs:
              rootFolderOrFile: 'frontend/build'
              includeRootFolder: false
              archiveType: 'zip'
              archiveFile: '$(Build.ArtifactStagingDirectory)/frontend-qa.zip'
              replaceExistingArchive: true

          - publish: $(Build.ArtifactStagingDirectory)/frontend-qa.zip
            artifact: drop_front_qa
            displayName: "Publish Frontend QA Artifact"


      # ---------- BUILD FRONTEND PROD ----------
      # (Dejamos este job como estaba, usualmente no se testea de nuevo para PROD)
      - job: BuildFrontPROD
        displayName: "Build Frontend (Production)"
        steps:
          - task: NodeTool@0
            inputs:
               # Dejamos 16.x aquÃ­ si es la versiÃ³n con la que quieres construir para PROD
              versionSpec: '16.x'
            displayName: "Set Node.js version (16.x)" 
          # ... (El resto de los pasos de BuildFrontPROD sin cambios) ...
          - script: |
              set -e
              cd frontend
              echo "ðŸŒ Building React app for Production..."
              echo "REACT_APP_BACKEND_URL=$(REACT_APP_BACKEND_URL_PROD)" > .env
              cat .env
              npm install
              npm run build

              echo "ðŸ§© Adding Node server for Azure..."
              cat > build/server.js <<'EOF'
              const express = require("express");
              const path = require("path");
              const compression = require("compression");
              const app = express();
              const port = process.env.PORT || 8080;
              app.use(compression());
              app.use(express.static(path.join(__dirname)));
              app.get("*", (_, res) => res.sendFile(path.join(__dirname, "index.html")));
              app.listen(port, () => console.log(`âœ… Frontend running on port ${port}`));
              EOF
              cat > build/package.json <<'EOF'
              {
                "name": "frontend-spa",
                "version": "1.0.0",
                "scripts": { "start": "node server.js" },
                "dependencies": {
                  "express": "^4.18.2",
                  "compression": "^1.7.4"
                }
              }
              EOF
              cd build
              npm install --production
            displayName: "Build Frontend for Production"
          - task: ArchiveFiles@2
            displayName: "Zip Frontend PROD build"
            inputs:
              rootFolderOrFile: 'frontend/build'
              includeRootFolder: false
              archiveType: 'zip'
              archiveFile: '$(Build.ArtifactStagingDirectory)/frontend-prod.zip'
              replaceExistingArchive: true
          - publish: $(Build.ArtifactStagingDirectory)/frontend-prod.zip
            artifact: drop_front_prod
            displayName: "Publish Frontend PROD Artifact"


      # ---------- BUILD & TEST BACKEND ---------- ### <<< MODIFICADO >>> ###
      - job: BuildAndTestBack ### <<< MODIFICADO >>> ###
        displayName: "Build & Test Backend (Go)" ### <<< MODIFICADO >>> ###
        steps:
          - task: GoTool@0
            inputs:
              # ### <<< MODIFICADO >>> ### AsegÃºrate que sea tu versiÃ³n
              version: '1.22.1' # O la versiÃ³n que estÃ©s usando localmente
            displayName: "Use Go version"

          # ### <<< MODIFICADO >>> ### Combinamos Tidy, Test y Build en un script
          - script: |
              cd Golang
              echo "ðŸ“¦ Tidying Go modules..."
              go mod tidy 
              echo "ðŸ§ª Running Go tests..."
              # Usamos './...' para buscar tests en todas las subcarpetas de Golang
              # Usamos '-v' para ver quÃ© tests corren
              go test ./... -v 
              echo "ðŸ”¨ Building Go binary for Linux..."
              GOOS=linux GOARCH=amd64 go build -o ../app # Construye el binario en la raÃ­z
            displayName: "Tidy, Test & Build Backend"
            # ### <<< AÃ‘ADIDO >>> ### Falla si 'go test' falla
            failOnStderr: true 

          - task: ArchiveFiles@2
            displayName: "Zip backend binary"
            inputs:
              rootFolderOrFile: 'app' # El binario 'app' en la raÃ­z del repo
              includeRootFolder: false
              archiveType: 'zip'
              archiveFile: '$(Build.ArtifactStagingDirectory)/backend.zip'
              replaceExistingArchive: true

          - publish: $(Build.ArtifactStagingDirectory)/backend.zip
            artifact: drop_back
            displayName: "Publish Backend Artifact"


  # ===========================
  # STAGE 2: DEPLOY TO QA
  # ===========================
  - stage: DeployQA
    displayName: "ðŸš€ Deploy to QA Environment"
    # ### <<< MODIFICADO >>> ### Depende de la nueva stage
    dependsOn: BuildAndTest 
    condition: succeeded()
    jobs:
      # ... (Tus jobs de DeployFrontendQA y DeployBackendQA sin cambios) ...
      - deployment: DeployFrontendQA
        displayName: "Deploy Frontend QA"
        environment: 'QA'
        strategy:
          runOnce:
            deploy:
              steps:
                - download: current
                  artifact: drop_front_qa
                - task: AzureWebApp@1
                  displayName: "Deploy Frontend to QA Web App"
                  inputs:
                    azureSubscription: '$(azureSubscription)'
                    appType: 'webApp'
                    appName: '$(webAppFrontendQA)'
                    package: '$(Pipeline.Workspace)/drop_front_qa/frontend-qa.zip'
      - deployment: DeployBackendQA
        displayName: "Deploy Backend QA"
        environment: 'QA'
        strategy:
          runOnce:
            deploy:
              steps:
                - download: current
                  artifact: drop_back
                - task: AzureWebApp@1
                  displayName: "Deploy Backend to QA Web App"
                  inputs:
                    azureSubscription: '$(azureSubscription)'
                    appType: 'webApp'
                    appName: '$(webAppBackendQA)'
                    package: '$(Pipeline.Workspace)/drop_back/backend.zip'
                    appSettings: |
                      -name WEBSITE_STARTUP_FILE -value ./app


  # ===========================
  # STAGE 3: DEPLOY TO PROD
  # ===========================
  - stage: DeployPROD
    displayName: "ðŸš€ Deploy to Production (Manual Approval)"
    dependsOn: DeployQA
    condition: succeeded()
    jobs:
      # ... (Tus jobs de DeployFrontendPROD y DeployBackendPROD sin cambios) ...
      - deployment: DeployFrontendPROD
        displayName: "Deploy Frontend PROD"
        environment: 'PRODU'
        strategy:
          runOnce:
            deploy:
              steps:
                - download: current
                  artifact: drop_front_prod
                - task: AzureWebApp@1
                  displayName: "Deploy Frontend to PROD Web App"
                  inputs:
                    azureSubscription: '$(azureSubscription)'
                    appType: 'webApp'
                    appName: '$(webAppFrontendPROD)'
                    package: '$(Pipeline.Workspace)/drop_front_prod/frontend-prod.zip'
      - deployment: DeployBackendPROD
        displayName: "Deploy Backend PROD"
        environment: 'PRODU'
        strategy:
          runOnce:
            deploy:
              steps:
                - download: current
                  artifact: drop_back
                - task: AzureWebApp@1
                  displayName: "Deploy Backend to PROD Web App"
                  inputs:
                    azureSubscription: '$(azureSubscription)'
                    appType: 'webApp'
                    appName: '$(webAppBackendPROD)'
                    package: '$(Pipeline.Workspace)/drop_back/backend.zip'
                    appSettings: |
                      -name WEBSITE_STARTUP_FILE -value ./app